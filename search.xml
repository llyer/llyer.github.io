<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot 官方的例子中 mvnw 文件有什么作用？]]></title>
    <url>%2Fmvnw.html</url>
    <content type="text"><![CDATA[Question: SpringBoot 官方的例子中 mvnw 文件有什么作用？ Answer: mvnw是一个maven wrapper script,它可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的命令. 原理: 它会寻找maven在你电脑环境变量path中的路径 如果没有找到这个路径它就会自动下载maven到一个默认的路径下,之后你就可以运行maven命令了 有时你会碰到一些项目的peoject和你本地的maven不兼容,它会帮你下载合适的maven版本,然后运行]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章解决 Java 中的时间，时区问题]]></title>
    <url>%2Fdatetime.html</url>
    <content type="text"><![CDATA[java中的时间存储到数据库数据中的时间一般有 datetime 和 timestamp 两种类型 使用 datetime 存储数据的时间精度在秒，使用时间戳的精度在毫秒，也就是 0.001 秒 java.util.data java.sql.data 的区别 https://stackoverflow.com/questions/2305973/java-util-date-vs-java-sql-date 这两种存储方式本身都没有什么优劣，但是有些同学可能在使用数据库存储 datetime 类型存储的时候发现数据库的时间总是比时间早了八个小时，这是由于时区的问题所导致的。 数据库连接上不设置时区，那么数据在存储为 datetime 类型的时候就会默认存储utc标准时区的的时间，而我们中国是在东八区，所以直接去数据库看就会早了八个小时 所以在我们在 properties 文件中配置数据库的连接的时候，就可以按照如下的方式设置： 关键部分为 &amp;serverTimezone=GMT%2B8，这条属性告诉数据库，我们目前的时区是哪个，方便各种 orm 框架在存储或者是读取时间时，选择合适的时区处理 12345# 数据库配置spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=password java 中的时间进行序列化把时间之类的序列化为 json 格式 序列化的时候如何序列化 java 中我们一般用 java.util.Date 来存储时间。可是大家都知道时间 spring boot 或者 spring mvc 中用的序列化工具是 jackson。jackson 序列化对象时使用注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package me.liluyang.jpa.entity;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import javax.persistence.*;import java.util.Date;import java.util.List;/** * 实体类Demo */@Data@Table@Entity@NoArgsConstructor@AllArgsConstructorpublic class User &#123; @Id private String id; private String username; private String password; private String gender; private Date lastLoginAt; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") private Date updateAt; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") private Date createAt; @OneToOne private Address address; @JsonIgnoreProperties("users") @ManyToMany(mappedBy = "users") private List&lt;Role&gt; roles; public User(String id, String username) &#123; this.id = id; this.username = username; &#125;&#125; 12345678910111213// junit 测试代码@Testpublic void testInsert() throws Exception &#123; User user = new User(); user.setUsername("john"); user.setLastLoginAt(new Date()); user.setUpdateAt(new Date()); user.setCreateAt(new Date()); // 三个输出分别是："lastLoginAt":1564208521736,"updateAt":"2019-07-27 06:22:01","createAt":"2019-07-27 14:22:01" // 如果我们要格式化输出时间的话一定要指定合适的时区 log.info("date:" + new ObjectMapper().writeValueAsString(user));&#125; 通过使用不同的 jackson 注解，我们发现返回给前台的时间类型格式也不一样。如果不设定时区，前端获取的时间就会有误，这是不可以的，而且如果不设置 jsonformat 时间会以时间戳的格式传递，这样对代码读起来不是很友好，所以最好是使用格式化时间加时间戳的方式去保存 参考链接 《HTTPS 配置教程（一）》 - 李鲁杨 ~]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 投影使用教程]]></title>
    <url>%2Fspring-data-jpa-projection-guide.html</url>
    <content type="text"><![CDATA[相信不少后端码农在进阶为 “高级增删改查程序员” 的道路上一般都会遇到类似这样的问题，我的数据库里面有一个 user 表，表中有 id, username, password 三个字段，前端用户在查询个人信息时，并不需要把 password 字段返回给前端，这个时候应该要使用怎样的方式进行优雅的处理呢？ 数据库表格： id username passowrd 01 zhangsan password01 02 lisi password02 03 wangwu password02 返回给前端的数据： 1234&#123; "id": "01", "username": "zhangsan"&#125; 面对这样的问题，最优雅的方式一定是使用 Spring Data JPA，如果你还没有用过，那么赶紧点开本教程吧！ Tips: 本教程对应的源代码地址：配合使用，学习更加迅速 实体类定义两个实体类，User 和 Role，User 和 Role 的关系是多对多的关系，当我们添加上 @Table 注解时，表示这两个实体类需要生成对应的具体的 Java 表格。 实体类中的 @Data, @NoArgsConstructor 等注解属于 lombok 框架。这个框架可以让我们在写 Java Bean 的时候省略 Getter 和 Setter 方法和构造器方法。详细用法，可以自行百度 1234567891011121314151617181920212223242526272829303132333435363738394041package me.liluyang.jpa.entity;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import javax.persistence.*;import java.util.List;/** * 实体类Demo */@Data@Table@Entity@NoArgsConstructor@AllArgsConstructorpublic class User &#123; @Id private String id; private String username; private String password; private String gender; @OneToOne private Address address; @JsonIgnoreProperties("users") @ManyToMany(mappedBy = "users") private List&lt;Role&gt; roles; public User(String id, String username) &#123; this.id = id; this.username = username; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package me.liluyang.jpa.entity;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.ManyToMany;import javax.persistence.Table;import java.util.List;/** * 实体类Demo */@Data@Table@Entity@NoArgsConstructor@AllArgsConstructorpublic class Role &#123; @Id private String id; private String name; @JsonIgnoreProperties(value = &#123;"address", "roles"&#125;) @ManyToMany private List&lt;User&gt; users; public Role(String id, String name) &#123; this.id = id; this.name = name; &#125;&#125; 投影的使用在上面呢，我们定义了两个最正常的实体User 和 Role，他们分别和数据库中的 user，role 表相对应。Spring Data JPA 支持的映射当中有两种方法，第一种是接口 interface 的方式，第二种是实体类 class 的方式 使用实体类（Java Bean）的方式接收 JPA 的返回值1. 返回包含基础数据属性的实体类这里的返回基础数据指 Integer，String 等基础的属性，而不包含 class 等嵌套实体类。 我们顶一个一个 UserDto 的实体类来接受数据库的返回值，注意实体类的定义方式，属性名称，Getter，Setter方法和 JPA entity 对象保持一致，另外只能有一个包含所有参数的构造方法，JPA 在查询到数据库数据时会使用这个构造方法将数据填充到当前对象当中。 在使用 123456789101112131415161718192021222324252627package me.liluyang.jpa.dto;import lombok.AllArgsConstructor;import lombok.Data;/** * 使用 dto class 效率很高，要什么数据，查询什么数据 * * 基础数据查询效率非常高 * */@Data@AllArgsConstructorpublic class UserDto &#123; private String id; private String username; private String gender; // 如果取消注释，可以正常的关联查询到实体类。正常，但是没有意义// private Address address; // 报错// private AddressDto address;&#125; 12345public interface UserRepository extends JpaRepository&lt;User, String&gt; &#123; UserDto findClassById(String id);&#125; 2. 返回包含基础数据属性的嵌套实体类JPA 本地并不支持使用 class 接受数据库中的嵌套数据。 使用接口（Interface）的方式接收 JPA 的返回值如果要使用接口接收 JPA 的返回结果，接口中需要实现 JPA entity 中属性同名的 Get 方法，例如属性中如果有 name 字段，则需要在接口中实现 getName() 方法 12345678package me.liluyang.jpa.dto;public interface UserView &#123; String getId(); String getUsername();&#125; 12345public interface UserRepository extends JpaRepository&lt;User, String&gt; &#123; UserView findViewById(String id);&#125; 除此之外，接口还支持返回嵌套实体类 123456789101112131415161718192021222324// interface 接受数据定义，address 是我定义的另外一个实体类public interface UserView2 &#123; String getId(); String getUsername(); AddressView getAddress(); Set&lt;RoleView&gt; getRoles();&#125;// UserRepository 代码定义UserView2 findView2ById(String id);// test 接口。使用 jackson 中的 new ObjectMapper() 将对象序列化@Testpublic void findView2() throws Exception &#123; UserView2 view = userRepository.findView2ById("1"); System.out.println(new ObjectMapper().writeValueAsString(view));&#125;// 输出结果// &#123;"address":&#123;"location":"深圳"&#125;,"id":"1","roles":[&#123;"name":"管理员"&#125;,&#123;"name":"用户"&#125;],"username":"赵敏"&#125; 使用 spel 表达式计算返回值接口中的代码定义如下： 12345678910111213141516171819202122package me.liluyang.jpa.dto;import org.springframework.beans.factory.annotation.Value;public interface UserView3 &#123; /** * * 开放式投影，开放式投影。开放式投影可以使用不完全和实体类相同的 getter 和 setter 方法，并且在运行时，动态的返回计算结果。 * * 开放式预测有一个缺点：Spring Data无法优化查询执行，因为它事先不知道将使用哪些属性。 * * 因此，当封闭投影无法满足我们的要求时，我们应该只使用开放投影。 * * 使用 @value 注解查询复合结果，@Value 注解内部的表达式是 spel 表达式。类似前端 Vue 等工具的计算属性 * * target 指真实的实体类对象 * @return */ @Value("#&#123;target.username + '&amp;' + target.gender&#125;") String getUsernameAndGender();&#125; 动态查询除了将以上介绍的集中普通的查询方式， JPA 还支持动态的设置返回数据结果集，在查询中将返回数据对象传入，获取合适的返回值 1234567891011121314151617181920// UserRepository 代码定义&lt;T&gt; T findByUsername(String username, Class&lt;T&gt; type);// junit 中的测试代码@Testpublic void findByDynamic() throws Exception &#123; User user = userRepository.findByUsername("张无忌", User.class); UserDto dto = userRepository.findByUsername("张无忌", UserDto.class); UserView view = userRepository.findByUsername("张无忌", UserView.class); System.out.println(new ObjectMapper().writeValueAsString(user)); System.out.println(new ObjectMapper().writeValueAsString(dto)); System.out.println(new ObjectMapper().writeValueAsString(view));&#125;// 控制台输出结果如下// &#123;"id":"2","username":"张无忌","password":null,"gender":null,"address":null,"roles":[&#123;"id":"1","name":"管理员"&#125;,&#123;"id":"2","name":"用户"&#125;]&#125;// &#123;"id":"2","username":"张无忌","gender":null&#125;// &#123;"id":"2","username":"张无忌"&#125; 如何在序列化时解决对象循环引用的问题使用 @jsonIgnore 注解和 @jsonIgnoreProperties 使用这种方式将当前对象中子对象中引用的所有 object 给切断，这样就不会产生循环 但是如果数据库中的关联关系足够复杂，依然会产生很多多余的查询。 学校 &gt; 院系 &gt; 学生 &gt; 课程 之类的关联 那么如果在合适的地方进行切断呢，这个目前比较合适的方式还是自己使用上面结果集映射的方式。根据不同场景下的 api 返回不同的查询结果 参考链接 《HTTPS 配置教程（一）》 - 李鲁杨 ~]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS 配置教程（二） 安全证书的续订]]></title>
    <url>%2Fhttps-config-guide-02.html</url>
    <content type="text"><![CDATA[在上一篇文章 《HTTPS 配置教程（一）》 中，我们教会了大家如何使用 Let’s Encrypt 免费 https 证书来为网站 http://liluyang.me 加密。但是这种方式有一个缺点呢，就是证书的有效期只有 90 天，90 天之后我们就要重新生成证书才能让网站继续使用 https 服务，如果不重新生成证书，那么访问网站的时候我们的网站就会被浏览器标记为不安全的，例如 Chrome 浏览器就提示如下： 今天呢就给大家讲一下安全证书的续订，以及一些可能会遇到的问题！ 证书续订其实续订证书的方式很简单，如果顺利的话，只要执行一步就可以了。还是执行以下命令： 12# 如果看不懂这行命令，请点击文章顶部的连接去看本系列文章的第一篇文章： https 配置教程certbot certonly --webroot -w /root/docker_nginx/html -d liluyang.me -d www.liluyang.me 如果正常的话，看到 shell 中产生以下提示，就代表证书生成成功了：123456789101112131415161718192021222324252627root@localhost:~/docker_nginx/conf# certbot certonly --webroot -w /root/docker_nginx/html -d liluyang.me -d www.liluyang.meSaving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator webroot, Installer NoneCert is due for renewal, auto-renewing...Renewing an existing certificatePerforming the following challenges:http-01 challenge for liluyang.mehttp-01 challenge for www.liluyang.meUsing the webroot path /root/docker_nginx/html for all unmatched domains.Waiting for verification...Cleaning up challengesIMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/liluyang.me/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/liluyang.me/privkey.pem Your cert will expire on 2019-09-30. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let&apos;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-leroot@localhost:~/docker_nginx/conf# 生成成功后，还是将 pem 文件拷贝到 nginx 的配置目录中重启 nginx 即可重新享受 https 服务了。 以上操作步骤的详细说明请参考：《HTTPS 配置教程（一）》 本片文章主要的问题就是解决我自己在重新生成证书时遇到的以下错误： 123456789101112131415161718192021222324252627282930313233root@localhost:~/docker_nginx/html# certbot certonly --webroot -w /root/docker_nginx/html -d liluyang.me -d www.liluyang.meSaving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator webroot, Installer NoneCert is due for renewal, auto-renewing...Renewing an existing certificatePerforming the following challenges:http-01 challenge for liluyang.mehttp-01 challenge for www.liluyang.meUsing the webroot path /root/docker_nginx/html for all unmatched domains.Waiting for verification...Cleaning up challengesFailed authorization procedure. www.liluyang.me (http-01): urn:ietf:params:acme:error:unauthorized :: The client lacks sufficient authorization :: Invalid response from https://liluyang.me [104.194.69.99]: &quot;&lt;!DOCTYPE html&gt;\n\n\n\n \n\n\n&lt;html class=\&quot;theme-next gemini use-motion\&quot; lang=\&quot;zh-Hans\&quot;&gt;\n&lt;head&gt;&lt;meta name=\&quot;generator\&quot; content=\&quot;Hexo 3.&quot;, liluyang.me (http-01): urn:ietf:params:acme:error:unauthorized :: The client lacks sufficient authorization :: Invalid response from https://liluyang.me [104.194.69.99]: &quot;&lt;!DOCTYPE html&gt;\n\n\n\n \n\n\n&lt;html class=\&quot;theme-next gemini use-motion\&quot; lang=\&quot;zh-Hans\&quot;&gt;\n&lt;head&gt;&lt;meta name=\&quot;generator\&quot; content=\&quot;Hexo 3.&quot;IMPORTANT NOTES: - The following errors were reported by the server: Domain: www.liluyang.me Type: unauthorized Detail: Invalid response from https://liluyang.me [104.194.69.99]: &quot;&lt;!DOCTYPE html&gt;\n\n\n\n \n\n\n&lt;html class=\&quot;theme-next gemini use-motion\&quot; lang=\&quot;zh-Hans\&quot;&gt;\n&lt;head&gt;&lt;meta name=\&quot;generator\&quot; content=\&quot;Hexo 3.&quot; Domain: liluyang.me Type: unauthorized Detail: Invalid response from https://liluyang.me [104.194.69.99]: &quot;&lt;!DOCTYPE html&gt;\n\n\n\n \n\n\n&lt;html class=\&quot;theme-next gemini use-motion\&quot; lang=\&quot;zh-Hans\&quot;&gt;\n&lt;head&gt;&lt;meta name=\&quot;generator\&quot; content=\&quot;Hexo 3.&quot; To fix these errors, please make sure that your domain name was entered correctly and the DNS A/AAAA record(s) for that domain contain(s) the right IP address. 产生这个问题的原因是在本次重新生成证书时我强制开启网站 http://liluyang.me 的 http 请求到 https 请求的跳转，导致 Let’s Encrypt 无法正确的校验域名和服务器的关联关系从而导致证书生成失败，解决的办法就是修改 nginx 配置文件 nginx.conf（如果存在 conf.d/default.conf 文件请优先修改此文件，具体原因请百度） 将 https 强制跳转关掉即可。 123456# 注释掉以下配置 关闭强制 https 跳转# server &#123;# listen 80;# server_name liluyang.me www.liluyang.me;# return 301 https://liluyang.me;# &#125; 在此执行生成证书的命令即可成功生成证书，配置成功后打开浏览器访问 https://liluyang.me 点击浏览器导航栏左侧 安全锁小图标，发现证书信息已经更新： 安全证书的有效时间已经更新，证明我们的设置已经生效了，你学会了吗？ 参考链接 《HTTPS 配置教程（一）》 - 李鲁杨 《Nginx 容器教程》 BY 阮一峰 《https 教程参考链接》 BY 阮一峰 《HTTPS中的TLS》 《Let’s Encrypt 证书生成工具Certbot》 BY Let’s Encrypt官方 《Let’s Encrypt 入门教程》 《Let’s Encrypt 使用教程，免费的SSL证书，让你的网站拥抱 HTTPS》 《HTTPS 简介及使用官方工具 Certbot 配置 Let’s Encrypt SSL 安全证书详细教程》 《数字证书及 CA 的扫盲介绍和工作原理》 ~]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
        <tag>计算机网络</tag>
        <tag>博客</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 下 Redis 的常用命令]]></title>
    <url>%2Fredis-command-in-ubuntu.html</url>
    <content type="text"><![CDATA[由于经常要在 服务器上修改 redis 的配置信息，每次都要搜索一下常用的命令，于是把命令整理了一下分享给大家 环境说明： 所有操作都在 腾讯云 Ubuntu 16.04 下进行。 Tips: 在腾讯云部署的 redis 服务，如果需要在外网访问，记得要在安全组配置中将 6379 端口打开！ 启动，关闭，重启 redis如果是用apt或者yum安装的redis，可以直接通过下面的命令停止/启动/重启redis 12345/etc/init.d/redis-server stop/etc/init.d/redis-server start/etc/init.d/redis-server restart 如果是通过源码安装的redis，则可以通过redis的客户端程序redis-cli的shutdown命令来重启redis 1.redis关闭redis-cli -h 127.0.0.1 -p 6379 shutdown 2.redis启动redis-server 如果上述方式都没有成功停止redis，则可以使用终极武器 kill -9 修改 redis 的配置大多数的应用场景下，往往是我们需要修改 redis 的一些功能，然后重启让其生效 使用 apt 安装的 redis 配置文件路径为：/etc/redis/redis.conf，可以使用以下命令编辑配置： 12# 编辑vi /etc/redis/redis.conf Tips: 编辑成功后按 esc + :wq 保存文件然后重启就可以生效啦 查看 redis 的运行状态1ps -ef | grep redis]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode1025. 除数博弈]]></title>
    <url>%2Fleetcode1025.html</url>
    <content type="text"><![CDATA[问题连接：1025. 除数博弈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * @lc app=leetcode.cn id=1025 lang=java * * [1025] 除数博弈 * * https://leetcode-cn.com/problems/divisor-game/description/ * * algorithms * Easy (52.33%) * Total Accepted: 875 * Total Submissions: 1.7K * Testcase Example: '2' * * 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 * * 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： * * * 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 * 用 N - x 替换黑板上的数字 N 。 * * * 如果玩家无法执行这些操作，就会输掉游戏。 * * 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 * * * * * * * 示例 1： * * 输入：2 * 输出：true * 解释：爱丽丝选择 1，鲍勃无法进行操作。 * * * 示例 2： * * 输入：3 * 输出：false * 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 * * * * * 提示： * * * 1 &lt;= N &lt;= 1000 * * 如果两人都是最佳玩家，那么偶数必胜，不存在玩家操作的问题。 * * 根据算法，如果初始时自己是偶数，那么可以保证自己每一轮操作之后都是偶数，当是最小的偶数 2 时，必胜。所以直接根据取余的值返回即可 * */class Solution &#123; public boolean divisorGame(int N) &#123; if (N % 2 == 0) return true; return false; &#125;&#125; ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode303. 区域和检索 - 数组不可变]]></title>
    <url>%2Fleetcode303.html</url>
    <content type="text"><![CDATA[问题连接：303. 区域和检索 - 数组不可变 Problem:给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例：12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。会多次调用 sumRange 方法。 Answer:12345678910111213141516171819202122232425262728293031323334353637383940package me.liluyang.leetcode;class NumArray &#123; private int sums[]; /** * 303. 区域和检索 - 数组不可变 * * url: https://leetcode-cn.com/problems/range-sum-query-immutable/comments/ * * 解题思路：最简单的动态规划 * * 题目要求的数据是第 i 天到第 j 天的数据和，如果每次求解时都进行循环，效率就比较低调用 n 次 时间复杂度就是 O（n*n） * * 这时我们通过生成一个 sums 数组数据和，sum是从第零个节点到第 i 个节点的数据和 * * 这样我们计算第 i 个元素到第 j 个元素的数据和，就不用了再从 nums 数组求值，变成了从 sums 数据求值： * * return i == 0 ? sums[j] : sums[j] - sums[i - 1]; * * 时间复杂度约为 O(nums.length) + O(n)，时间复杂度会降低很多 * * @param nums * @return */ public NumArray(int[] nums) &#123; if (nums.length == 0) return; sums = new int[nums.length]; sums[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; sums[i] = sums[i - 1] + nums[i]; &#125; &#125; public int sumRange(int i, int j) &#123; return i == 0 ? sums[j] : sums[j] - sums[i - 1]; &#125;&#125; 运行结果截图: ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式学习笔记]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[观察者模式，类结构图如下所示： 对象接口（被观察者）123456789101112131415package com.example.demo.design_pattern;/** * 被观察者 * * 有 添加，删除观察者的方法和更新观察者状态的方法 */public interface Subject &#123; void register(Observer observer); void remove(Observer observer); void send(String message);&#125; 观察者接口123456789package com.example.demo.design_pattern;/** * 观察者 */public interface Observer &#123; void receive(String message);&#125; 对象的实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.example.demo.design_pattern;import java.util.ArrayList;import java.util.List;import java.util.Timer;import java.util.TimerTask;/** * 被观察者 * * 被观察者一般是内容提供者 * * 有一个容器，来盛放所有的观察者 * * 有 添加，删除观察者的方法和更新观察者状态的方法 */public class NewsPaper implements Subject &#123; List&lt;Observer&gt; users; public NewsPaper() &#123; users = new ArrayList&lt;&gt;(); generateNews(); &#125; /** * 模拟产生新闻，每个2s发送一次 */ private void generateNews() &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; int titleCount = 1; int contentCount = 1; @Override public void run() &#123; send("title:" + titleCount++ + "content:" + contentCount++); &#125; &#125;, 1000, 1000); &#125; /** * 注册用户（消费者） * @param observer */ public void register(Observer observer) &#123; if (!users.contains(observer)) &#123; users.add(observer); &#125; &#125; /** * 移除用户（观察者） * @param observer */ public void remove(Observer observer) &#123; if (users.contains(observer)) &#123; users.remove(observer); &#125; &#125; /** * 报社推送文章 * * @param message */ public void send(String message) &#123; for (Observer observer: users) &#123; observer.receive(message); &#125; &#125;&#125; 核心方法：添加订阅者，删除订阅者，更新消息接口 观察者的实现类12345678910111213141516171819202122232425262728package com.example.demo.design_pattern;/** * 被观察者 * * 有一个容器，来盛放所有的观察者 * * * 有 添加，删除观察者的方法和更新观察者状态的方法 */public class User implements Observer&#123; private String id; public User(String id) &#123; this.id = id; &#125; /** * 根据输出，每个用户都会受到报社每间隔一秒发送过来的信息 * * @param message */ @Override public void receive(String message) &#123; System.out.println(id + "收到的报社发送的消息是：" + message); &#125;&#125; 测试类：12345678910111213141516package com.example.demo.design_pattern;/** * 测试主函数 */public class ZTest &#123; public static void main(String[] args) &#123; NewsPaper newsPaper = new NewsPaper(); User user; for (int i = 0; i &lt; 10; i++) &#123; user = new User("user:"+i); newsPaper.register(user); &#125; &#125;&#125; 核心方法：订阅接口、这个接口是每次被订阅者更新消息时：需要被被订阅者调用的接口，在这个接口里面订阅者实现具体的业务内容。 应用场景类似于： 报社的用户订阅报纸 报社是对象，所有的用户是观察者，用户订阅报社的报纸期刊，然后报社发布期刊之后，用户收到报纸 MVC 模式 model 是对象，是被订阅者。view 是观察者，观察者监听model，如果 model 的内容发生了变化，那么view 监听到内容变化，更新视图的内容 互联网产品中的订阅模式 微博里面的关注，只有关注了之后，被关注者发送了内容之后关注着才可以收到推送 前端的一些 MVVM 框架也有用到订阅-发布模式，类似于 Vue.js 观察者模式和 MVC 的关系详解MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。 参考链接 观察者模式 从Vue源码看观察者模式 观察者模式应用场景实例 哈票网]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode121. 买卖股票的最佳时机]]></title>
    <url>%2Fleetcode121.html</url>
    <content type="text"><![CDATA[问题连接：121. 买卖股票的最佳时机 Question:给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 Answer:12345678910111213141516171819202122232425262728293031class Solution121 &#123; /** * * problem: 121. 买卖股票的最佳时机 * * url: https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/ * * 解题思路：最简单的动态规划 * * 在第 i 天时可能产生的最大的利润是 Max(i) = Max(Max(i-1), prices[i] - minBefore); * * 其中 max(i) 和 minBefore 都需要在每次的循环中更新 * * @param prices * @return */ public int maxProfit(int[] prices) &#123; // 校验输入 if (prices.length == 0) return 0; int minBefore = prices[0]; int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) &#123; minBefore = Math.min(minBefore, prices[i]); // 比较之前最小的和现在最小的 maxProfit = Math.max(maxProfit, prices[i] - minBefore); &#125; return maxProfit; &#125;&#125; ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP 三次握手和四次挥手]]></title>
    <url>%2FTCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[TCP 三次握手和四次挥手(面试常客) 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。 漫画图解： 图片来源：《图解HTTP》 简单示意图： 客户端–发送带有 SYN 标志的数据包–一次握手–服务端服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 为什么要三次握手？三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 此处非常重要，一定要理解，三次握手的目的是为了达成： 发送方：确认自己发送接收正常，对方也发送接收正常 接收方：确认自己发送接收正常，对方也发送接收正常 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 为什么要传回 SYN？接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。 传了 SYN,为啥还要传 ACK？双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 为什么要四次挥手？任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 断开一个 TCP 连接则需要“四次挥手”： 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号服务器-关闭与客户端的连接，发送一个FIN给客户端客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1 上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Redis + Spring Boot Cache 使用教程]]></title>
    <url>%2FSpring%20Boot%20Redis%20%2B%20Spring%20Boot%20Cache%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[本文配套代码地址： Spring Boot Redis + Spring Boot Cache 使用教程，强烈建议下载代码配套阅读！ Redis 是开发者们使用最多的内存数据库，内存数据库的很大的一个特性就是用来做缓存，本片文章我们通过 Spring Boot Cache 来整合 Redis，将 Redis 作为我们关系型数据库的缓存。 项目配置在 pom.xml 文件中导入依赖： 12345678910111213141516171819202122&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- cache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 其他的更多依赖以及可选项请查看源代码 配置文件如下图所示: 12345678910111213141516171819202122232425262728# portserver.port=8080# actuator 健康监控info.name=service-redisinfo.server.port=$&#123;server.port&#125;# redisspring.redis.database=0spring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.password=your password# spring cache type 指明使用的缓存类型是Redis#spring.cache.type=redis# database settingsspring.jpa.database=mysqlspring.jpa.show-sql=falsespring.jpa.hibernate.ddl-auto=updatespring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategyspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect# data sourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/learn_redis?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driverClassName=com.mysql.jdbc.Driver 当我们在 Spring boot 中配置好 Redis 并且在 Service 层代码中设置对应 Cache，Spring 会自动帮我们检测缓存数据源，如果发现当前项目中有可用的 Redis，那么就会设置缓存数据源为 Redis Service 层的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class UserService &#123; @Autowired UserRepository userRepository; public List&lt;User&gt; list() &#123; System.out.println("进入 list users service 方法"); return userRepository.findAll(); &#125; // 查询用户，并且值缓存用户ID小于10的用户 @Cacheable(value = "user", key = "#id", condition = "#id &lt; 10") public User get(Integer id) &#123; System.out.println("进入 service get 方法"); return userRepository.findById(id).orElse(null); &#125; @CachePut(value = "user", key = "#user.id", condition = "#user.id &lt; 10") public User save(User user) &#123; System.out.println("进入 service save 方法"); return userRepository.save(user); &#125; @CachePut(value = "user", key = "#user.id", condition = "#user.id &lt; 10") public User update(User user) &#123; System.out.println("进入 service update 方法"); return userRepository.save(user); &#125; // Evict 清除缓存，一般用在删除方法之上，在删除时，也将缓存数据清空 @CacheEvict(value = "user", key = "#id") public void delete(Integer id) &#123; System.out.println("进入 service delete 方法"); userRepository.deleteById(id); &#125;&#125; 上图中有一些是属于 org.springframework.cache.annotation.* 包下面的注解。这些注解定义我们要缓存的数据，规则等信息。 Cacheable 对应 get 方法。查询数据中进行缓存，value 对应的是仓库，缓存的数据为方法 return 的数据 CachePut 对应 post，put 方法。用在插入或者更新时，将变动的信息更新到缓存。 CacheEvict 对应 delete 方法。用在需要将缓存中的数据移除的时候。 更多详细的文档请访问：https://docs.spring.io/spring/docs/4.3.15.RELEASE/spring-framework-reference/html/cache.html 如何验证缓存已经正常运行？在项目中执行以下测试用例12345678910@Testpublic void getTest3() throws Exception &#123; User u1 = new User(); u1.setId(1); u1.setName("曾阿牛"); u1.setAge(18); userService.save(u1); User u3 = userService.get(1); System.out.println("第一次查询：" + u3.getAge());&#125; 发现 Mysql 和 Redis 缓存中同时多了以下数据： redis:12345127.0.0.1:6379&gt; keys *1) "user::1"2) "runtime"3) "caches"127.0.0.1:6379&gt; mysql: 以上两张图片证明了，我们不仅将数据保存到了 Mysql 数据库中，还将数据同时添加到了缓存当中。此时，如果我们再单独的执行 userService.get(1) 方法，那么查询会直接将 Redis 缓存中的数据返回，这样相对于从数据库查询数据速度要快很多 如何保证 Mysql 和 Redis 数据的一致性？Question: 这个时候可能有人会问？那我数据的增删改查怎么办？我的数据要更新，更新后数据库里面的数据和缓存不一致怎么办？那岂不是缓存里面的数据就变成脏数据了？缓存的设置怎么设置条件，比如：我们只想缓存 id 小于 10 的用户的数据，应该怎么做？ Answer: 其实解决办法也不是很复杂，我们只需要在所有可能操作要这个对应数据的地方加上对应的缓存注解就可以，例如：更新数据库时也更新缓存就可以了。具体的代码在上面的代码上已经有了。大家可以下载代码自行检验。添加以下条件进行过滤就可以了： 1@CachePut(value = "user", key = "#user.id", condition = "#user.id &lt; 10") 接下来我们来验证一下过滤条件是否生效，分别运行一下两个测试用例： 123456789101112131415161718192021@Testpublic void getTest3() throws Exception &#123; User u1 = new User(); u1.setId(9); u1.setName("灭绝师太"); u1.setAge(50); userService.save(u1); User u3 = userService.get(9); System.out.println("第一次查询：" + u3.getAge());&#125;@Testpublic void getTest3() throws Exception &#123; User u1 = new User(); u1.setId(11); u1.setName("张三丰"); u1.setAge(108); userService.save(u1); User u3 = userService.get(11); System.out.println("第一次查询：" + u3.getAge());&#125; 此时在 Mysql 和 Redis 中的数据状态如下： redis:123456127.0.0.1:6379&gt; keys *1) "user::1"2) "runtime"3) "caches"4) "user::9"127.0.0.1:6379&gt; mysql: 可以发现系统并没有将 id 为 11 的数据保存在缓存当中。 参考链接 配套代码 Spring Cache 官方文档 Redis 常用命令整理 设置 Redis 服务可以被远程访问]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Redis</tag>
        <tag>缓存</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 提交规范]]></title>
    <url>%2FGit%20%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[分享自： 阮一峰的网络日志：Commit message 和 Change log 编写指南 程序员DD的个人网站：你可能会忽略的 Git 提交规范]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 可视化工具推荐]]></title>
    <url>%2FRedis%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90.html</url>
    <content type="text"><![CDATA[分享自： 王哥哥的个人网站：八一八你用过的Redis可视化工具 ~]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 关键字 final, static, abstratc, this, super]]></title>
    <url>%2FJava%20%E5%85%B3%E9%94%AE%E5%AD%97%20final%2C%20static%2C%20abstratc%2C%20this%2C%20super.html</url>
    <content type="text"><![CDATA[Java 有哪些关键字？final, static, abstract, this, super 等等 final 有什么作用和优缺点？final 是 java 语言中的保留关键字，可以修饰 class, method, variable。final 变量不可变，代表了可以安全的在多线程之间共享，final 关键字提高了性能 final 修饰的类无法被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。 final 修饰方法。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用 final 方法进行这些优化了。类中所有的 private 方法都隐式地指定为 final。 final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 final with classjavase 中有哪些类使用了 final 关键字？ String类： 使用 final 关键字防止类被篡改： 12345678910111213141516171819202122232425/** * FinalClass.java * * 下面这个类如果写成 extends Parent 会报错，因为 Parent 已经被final修饰，不能继承 * *///public class FinalClass extends Parent &#123;// private Integer sum(Integer num1, Integer num2) &#123;// return num1 + num2;// &#125;//&#125;public class FinalClass &#123; private Integer sum (Integer num1, Integer num2) &#123; return num1 + num2; &#125;&#125;final class Parent &#123; private String name = "zhangsan"; public String getName() &#123; return this.name; &#125;&#125; final with method123456789101112131415161718192021222324252627/** * final 修饰方法时，方法无法被继承 * */public class FinalMethod &#123; public int multiply (Integer num1, Integer num2) &#123; return num1 * num2; &#125; public final int sum (Integer num1, Integer num2) &#123; return num1 + num2; &#125;&#125;class FinalMethodChild extends FinalMethod &#123; @Override public int multiply(Integer num1, Integer num2) &#123; return num1 * num2; &#125; // 方法会报错，因为 final 方法无法被继承// public final int sum (Integer num1, Integer num2) &#123;// return num1 + num2;// &#125;&#125; final with variable final 变量一般是大写 final 变量如果引用的是基本类型，那么不可以修改重新赋值， final 如果引用的是对象，那么不可以修改引用，但是对象本身是可以变化的 12345678910111213public class FinalVariable &#123; public void change () &#123; final String NAME = "zhangsan"; // name = "lisi"; // 错误 final ArrayList list; list = new ArrayList(); list.add("zhangsan"); // list = new ArrayList(); // 错误 &#125;&#125; static 关键字static 修饰的属性和方法都属于类，而不属于某个具体 new 出来的对象，所有对象共享相同的 static 属性和方法 static 修饰的属性和方法可以直接通过 类名.变量 或者 类名.方法() 调用 abstract 关键字abstract 关键字可以修饰类或方法。 abstract 类可以扩展（增加子类），但不能直接实例化。 abstract 方法不在声明它的类中实现，但必须在某个子类中重写。 123public abstract class MyClass&#123;&#125; public abstract String myMethod(); 采用 abstract 方法的类本来就是抽象类，并且必须声明为 abstract。 abstract 类不能实例化。 仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类。 如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。 abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。 final 类的方法都不能是 abstract，因为 final 类不能有子类。 this 关键字this 关键字代之当前对象，可以通过 this 引用当前对象的变量或者方法 super 关键字super 关键字代指父对象，用来访问父对象的变量和方法 关键字注意事项 abstract 关键字和 final 关键字天生互斥，不能同时使用 super 调用父类中的其他构造方法时，调用时要放在构造方法的首行！this 调用本类中的其他构造方法时，也要放在首行。 this，super不能用在 static 方法中。static 中也不能调用非 static 修饰的变量或者方法，原理也是一样的。类范畴的无法调用对象范畴的东西，this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西。 静态代码快和非静态代码快的区别，静态代码块无论创建多少个实例都执行一次，非静态代码快每创建一个实例执行一次 静态代码块和构造方法的区别，不同的对象用不同的构造方法执行出来的对象可能不同，静态代码快就是所有对象相同的那部分 参考链接 final,static,this,super 关键字总结 ~]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一张图看懂 Mysql 的连接查询]]></title>
    <url>%2F%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82%20Mysql%20%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[分享自廖雪峰的官方网站：连接查询 连接查询SQL 的连接 JOIN 查询有多种，到底应该用哪种呢？其实我们用图来表示结果集就一目了然了。 假设查询语句是： 1SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录： 结语JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT … FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件…&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序。 ~]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 学习笔记二：Docker + Jenkins + Nginx]]></title>
    <url>%2FJenkins%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9ADocker%20%2B%20Jenkins%20%2B%20Nginx.html</url>
    <content type="text"><![CDATA[本篇文章继续以 https://liluyang.me 为案例来讲解如何实现持续集成。主要涉及的技术有 Docker，Jenkins，Nginx，Hexo 准备工作 正确的安装 Docker 正确的使用 Docker 安装了 Jenkins，Nginx 配置过程启动 Nginx，映射宿主机目录12345678# 将 html 目录和 conf 目录映射到宿主机docker run \--volume "/root/docker_nginx/html":/usr/share/nginx/html \--volume "/root/docker_nginx/conf":/etc/nginx \-p 80:80 \-p 443:443 \-d \nginx 启动 Jenkins，映射宿主机目录12345678910# 在 jenkins 中定义一个 nginx 的 html 工作目录。将这个目录也映射到宿主机的 html 目录中，这样 jenkins 将 git 中的项目文件拉取到jenkins 的工作目录。然后再拷贝到 nginx 的工作目录就完成了持续集成的过程docker run \ -u root \ -d \ -p 8080:8080 \ -p 50000:50000 \ -v jenkins-data:/var/jenkins_home \ -v /var/run/docker.sock:/var/run/docker.sock \ --volume "/root/docker_nginx/html":/usr/share/jenkins/html \ jenkinsci/blueocean 配置 Jenkins，持续集成拉取 Git 项目安装配置好 jenkins 之后，新建项目： 配置设置如下： 其中将 git 地址修改为你自己项目的地址，分支也设置为对应的分支。 最后一步，在构建中选择 执行Shell，执行以下脚本命令： 123456789101112#!/bin/bash # 当前 docker 容器映射的宿主机的地址www_path=/usr/share/jenkins/html# jenkins将项目从Git拷贝过来的位置work_path=/var/jenkins_home/workspace/hexorm -rf /usr/share/jenkins/html/*#将生成的文件拷贝到当前的工作目录，由于当前目录和宿主机中的 nginx 目录对应，所以就自动更新了 nginx 的内容cp -rf /var/jenkins_home/workspace/hexo/* /usr/share/jenkins/html 以上全部执行完成后，返回 jenkins 的任务界面，选择立即构建。如下图： 构建完成后可以点击构建历史中刚刚构建的项目中选择控制台输出查看日志是否构建成功。 配置 Github，将 Webhooks 的通知发送到 Jenkins打开你的 Github 项目，设置 hook 的通知地址 接下来可以修改下文件然后检查确认以下流程是否成功了。 执行修改文件 提交到Git Jenkins 触发提交事件的锚点而执行自动构建。 访问 Nginx 查看项目的变化 我们可以通过检查 Webhook 日志的方式来判断我们是否正确的接收到了 Github 的通知，如下图所示： 如果发现日志正常，那么打开你的网站检查一下，更新应该已经成功了。 到此为止，如果不出意外，你的 Jenkins 持续集成已经完成了。 快去尝试一下吧~ 参考链接 《手把手教你搭建Jenkins+Github持续集成环境》 BY muyinchen ~]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Hexo</tag>
        <tag>Jenkins</tag>
        <tag>Nginx</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 忘记密码怎么办？]]></title>
    <url>%2FJenkins%20%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F.html</url>
    <content type="text"><![CDATA[Jenkins 如果忘记了密码可以按照以下教程来重置密码： https://www.jianshu.com/p/e8bc90a1aad8]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS 配置教程]]></title>
    <url>%2FHTTPS%20%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[本文将以本站 http://liluyang.me 升级到 https://liluyang.me 的过程来分享一下 https 的原理，http 和 https 的区别，以及如何将网站从 http 升级到 https。 引言为什么要用 https？https 更安全。甚至为了安全，一个专业可靠的网站， https 是必须的。 Firefox 和 Chrome 都计划将没有配置 SSL 加密的 https 网站标记为不安全（貌似 Firefox50 已经这么干了），目前它们也正在联合其他相关的基金会与公司推动整个互联网 https 化，现在大家访问的一些主要的网站。如 Google 多年前就已经全部启用 https ，国内的淘宝、搜狗、知乎、百度等等也全面 https 了。甚至 Google 的搜索结果也正在给予 https 的网站更高的排名和优先收录权。 要需要掌握哪些知识？拥有基础的 Linux 系统知识，常用的 Shell 命令。 需要有什么资源？如果你只是要测试 https，请查看Nginx 容器教程 如果你要在生产环境使用 https，请接着往下看： 一个服务器，一个域名，并且已经正确的将域名指向了你的服务器，并且拥有服务器的 SSH 权限 Tips: 需要注意的是如果是在国内阿里云或者腾讯云购买的域名请备案，否则即使你正确的配置了你的域名，可能也依然无法访问你的服务器，因为在国内备案是必须的。 关键词http 和 https简单来说，http 是一个传输网页内容的协议，比如你看到的 http 开头的网站 http://www.163.com，其网页上的文字、图片、 CSS、JS 等文件都是通过 http 协议传输到我们的浏览器，然后被我们看到。 而 https 可以理解为 HTTP over SSL/TLS ，好端端的 http 为什么需要 over SSL/TLS 呢，因为 http 是明文传输的，通过 http 协议传输的内容很容易被偷看和篡改，为了安全（你肯定不想被人偷看或者篡改网页内容吧，比如网站银行密码什么的。）就为 http 协议再加上了一层 SSL/TLS 安全协议，所以就有了 https。 SSL/TLSHTTP over SSL/TLS 字面意思就是带 安全套接层 的 http 协议，内心纯洁的同学也可以理解为 带安全套的 http，因为带了安全套，所以当然会比较安全（/(ㄒoㄒ)/~~）。其中 SSL 是 Secure Sockets Layer 的缩写，是 “安全套接层” 的意思。TLS 是 Transport Layer Security 的缩写，是 传输层安全协议 的意思。SSL 和 TLS 是同一个东西的不同阶段，理解为同一个东西也行，都是安全协议就对了。 CA证书颁发机构（CA, Certificate Authority）即颁发数字证书的机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。 Let’s EncryptLet&#39;s Encrypt 成立于 2015 年的数字证书认证机构，成立的目的就是为了推行 https 协议在全世界的普及。主要赞助商包括电子前哨基金会、Mozilla基金会、Akamai以及思科。Let&#39;s Encrypt 旨在以自动化流程消除手动创建和安装证书的复杂流程，并推广使万维网服务器的加密连接无所不在，为安全网站提供免费的 SSL/TLS 证书。 说人话就是 Let’s Encrypt 就是一个可以给我们颁发授信证书的 CA 组织。 CertbotLet’s Encrypt 官方推出的授信证书生成客户端。可以在 Debian，CentOS 等主流系统上运行 官方链接如下：https://certbot.eff.org/ 获取证书要升级到 https 首先要获得 CA 签发的安全证书文件，我们选择的证书签发机构是 Let’s Encrypt，目前 Let’s Encrypt 推荐的方法是安装 Certbot 工具通过校验服务器和域名的归属权方式来获取证书 安装Certbot如果你的英文能力比较好，那么请访问 Certbot官网 根据官方教程来下载，官方教程更加细致，出了问题也方便查看官方的第一手资料。当然你也可以根据以下命令来安装 Certbot 工具，这里我们以 debian9 系统为例来安装 12# 下载 certbot，如果是 centOS 等内核，可以使用 yum 命令apt install certbot 生成证书certbot 安装成功后，我们有两种模式来获取证书 第一种模式 Webroot1certbot certonly --webroot -w /root/docker_nginx/html -d liluyang.me -d www.liluyang.me 这个命令会为 liluyang.com 和 www.liluyang.com 这两个域名生成一个证书 --webroot 模式会在 /root/docker_nginx/html 中创建 .well-known文件夹，这个文件夹里面包含了一些验证文件，certbot 会通过访问 example.com/.well-known/acme-challenge 来验证你的域名是否绑定的这个服务器。这个文件夹就是你 Nginx 下 index.html 所在的目录，请自行根据自己服务器 Nginx 的配置情况修改这个参数。 如果执行成功，命令行会大致输出以下参数表示成功： 12345678910111213IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/liluyang.me/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/liluyang.me/privkey.pem Your cert will expire on 2019-07-01. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run "certbot renew" - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 以上信息中包含了生成后的证书的位置，过期时间等信息，根据提示信息我们打开 /etc/letsencrypt/live/ 文件夹，检查这个文件夹中是否有你生成的对应网站的证书文件，如果成功，应该如下图所示： 这个命令在大多数情况下都可以满足需求，如果失败了，请看下一种模式。 第二种模式 Standalone如果你已经通过第一种模式生成证书成功，请跳过这里，直接看下一章 但是有些时候我们的一些服务并没有根目录，例如一些微服务，这时候使用 --webroot 就走不通了。certbot 还有另外一种模式 --standalone， 这种模式不需要指定网站根目录，他会自动启用服务器的 443 端口，来验证域名的归属。我们有其他服务（例如nginx）占用了 443 端口，就必须先停止这些服务，在证书生成完毕后，再启用。 1certbot certonly --standalone -d example.com -d www.example.com 证书生成完毕后，我们可以在 /etc/letsencrypt/live/ 目录下看到对应域名的文件夹，里面存放了指向证书的一些快捷方式。 这时候我们的第一生成证书已经完成了，接下来就是配置我们的 web 服务器，启用 HTTPS。 如果生成失败，并且你自己搜索之后又没有能力解决，请在评论留言 如果生成失败，并且你自己搜索之后又没有能力解决，请在评论留言 如果生成失败，并且你自己搜索之后又没有能力解决，请在评论留言 安装证书证书生成生成后，我们还要做最后的一步就是把证书的配置信息添加到 nginx 的 conf 目录的 certs 文件夹中。我个人的 Nginx 是通过 docker 镜像的方式运行的，并且我将本地的 /root/docker_nginx/conf 文件夹设置为了 Nginx 的配置文件夹，所以现在我们将证书 cert.pem 和 privkey.pem 拷贝到这个目录。配置目录如下 在 Nginx 的配置文件 nginx.conf 末尾添加以下配置，注意修改对应的配置参数，下面的配置模板仅供参考。 如果存在 conf.d/default.conf 文件请优先修改此文件，具体原因请百度 1234567891011121314151617181920# 443 https 配置server &#123; listen 443 ssl http2; server_name liluyang.me www.liluyang.me; ssl on; ssl_certificate /etc/nginx/certs/cert.pem; ssl_certificate_key /etc/nginx/certs/privkey.pem; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125; 重启 Nginx 到此为止，我们就已经成功的完成了 https 的配置。 现在打开我的博客 https://liluyang.com 就可以在浏览器端看到标有 安全 的网站标识字样了，如下图： 注意事项如果是 docker 部署的 nginx，最后重启启动 docker 时要将 443（https） 端口映射出来，否则无法访问服务器的 443（https） 端口的。1234567docker run \ --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \ --volume &quot;$PWD/conf&quot;:/etc/nginx \ -p 80:80 \ -p 443:443 \ -d \ nginx 可选配置强制使用 https 访问网站将 http 请求转发到 https 请在配置文件夹中添加以下配置，然后重启 Nginx 即可 12345server &#123; listen 80; server_name liluyang.me www.liluyang.me; return 301 https://liluyang.me;&#125; 自动续订细心的同学可能会发现， https 证书的有效时间是非常短的，只有三个月，那么每隔三个月我们都要操作一次吗？其实不是的，我们可以用过自动续订的方式来刷新我们的证书有效时间。 测试自动续订1certbot renew --dry-run 如果测试成功，会生成如下提示：1234567891011121314151617181920212223242526272829303132333435Saving debug log to /var/log/letsencrypt/letsencrypt.log- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Processing /etc/letsencrypt/renewal/liluyang.me.conf- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Cert not due for renewal, but simulating renewal for dry runPlugins selected: Authenticator webroot, Installer NoneRenewing an existing certificatePerforming the following challenges:http-01 challenge for liluyang.mehttp-01 challenge for www.liluyang.meWaiting for verification...Cleaning up challenges- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -new certificate deployed without reload, fullchain is/etc/letsencrypt/live/liluyang.me/fullchain.pem- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -** DRY RUN: simulating 'certbot renew' close to cert expiry** (The test certificates below have not been saved.)Congratulations, all renewals succeeded. The following certs have been renewed: /etc/letsencrypt/live/liluyang.me/fullchain.pem (success)** DRY RUN: simulating 'certbot renew' close to cert expiry** (The test certificates above have not been saved.)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -IMPORTANT NOTES: - Your account credentials have been saved in your Certbot configuration directory at /etc/letsencrypt. You should make a secure backup of this folder now. This configuration directory will also contain certificates and private keys obtained by Certbot so making regular backups of this folder is ideal. 手动执行自动续订1certbot renew -v 开启自动续订自动续订也可以用 certbot 来实现，自动续订之后会更新 pem 文件到 /etc/letsencrypt/live/example.com/ 。如果你的 nginx 配置没有直接指向 /etc/letsencrypt/live/example.com/ 文件夹，请记得将 pem 文件夹拷贝到你的配置文件夹中 1certbot renew --quiet --no-self-upgrade 参考链接 《Nginx 容器教程》 BY 阮一峰 《https 教程参考链接》 BY 阮一峰 《HTTPS中的TLS》 《Let’s Encrypt 证书生成工具Certbot》 BY Let’s Encrypt官方 《Let’s Encrypt 入门教程》 《Let’s Encrypt 使用教程，免费的SSL证书，让你的网站拥抱 HTTPS》 《HTTPS 简介及使用官方工具 Certbot 配置 Let’s Encrypt SSL 安全证书详细教程》 《数字证书及 CA 的扫盲介绍和工作原理》 ~]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
        <tag>计算机网络</tag>
        <tag>博客</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假如地球突然失去氧气五秒钟会怎样？]]></title>
    <url>%2F%E5%81%87%E5%A6%82%E5%9C%B0%E7%90%83%E7%AA%81%E7%84%B6%E5%A4%B1%E5%8E%BB%E6%B0%A7%E6%B0%94%E4%BA%94%E7%A7%92%E9%92%9F%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F.html</url>
    <content type="text"><![CDATA[想象一下，假如地球的所有氧气都突然消失了，仅仅消失五秒，会怎样？ 我们要屏住呼吸吗？ 大气会怎样？ 环境会怎样？ document.getElementById('bilibili').setAttribute("style","width:100%"); document.getElementById('bilibili').style.minHeight='200px'; if (window.screen.height >window.screen.width) { document.getElementById('bilibili').style.height=window.screen.height / 4 + 'px'; } else { document.getElementById('bilibili').style.height=window.screen.height / 2 + 'px'; } Tips：点击视频右上角的去Bilibili观看，可以查看高清 1080P 源视频 ~~~]]></content>
      <tags>
        <tag>视频</tag>
        <tag>科普</tag>
        <tag>假如（WhatIF）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg 常用命令]]></title>
    <url>%2FFFmpeg%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[FFmpeg 是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库。 “FFmpeg”这个单词中的“FF”指的是“Fast Forward（快速前进）”。有些新手写信给“FFmpeg”的项目负责人，询问FF是不是代表“Fast Free”或者“Fast Fourier”等意思，“FFmpeg”的项目负责人回信说：“Just for the record, the original meaning of “FF” in FFmpeg is “Fast Forward”…” 动图转视频1ffmpeg -i animated.gif -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" video.mp4 动图转图片序列逐帧输出，将视频的所有帧输出到制定文件夹，例如一秒 24 帧，视频一共 10 秒，输出后就是 24*10=240 帧1ffmpeg -i input.gif /images/image_%04d.png 动图转视频参考教程地址：点我12ffmpeg -i animated.gif -movflags faststart -pix_fmt yuv420p -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2" video.mp4 视频，GIF添加水印1ffmpeg -i input.gif -vf "drawtext=fontfile=simhei.ttf: text='你的水印':x=600:y=330:fontsize=18:fontcolor=yellow:shadowy=2" manu.gif 视频转图片序列1ffmpeg -i "cut01.mp4" ./cut01/image_%04d.png 合并音频和视频1ffmpeg -i video.mp4 -i audio.m4a -acodec copy -vcodec copy output.mp4 截取视频中的一段1ffmpeg -i ./input.mp4 -vcodec copy -acodec copy -ss 00:00:10 -to 00:00:15 ./cut01.mp4 -y 参考链接：https://www.cnblogs.com/wainiwann/p/6972954.html 裁剪视频裁剪视频的大小，一定要指定码率 1ffmpeg -i cutout1.mp4 -strict -2 -vf crop=400:720:400:0 -b 10M out2.mp4 图片序列转视频第一个 -r 指的是帧数，-b 指的是码率 -s 是分辨率 1234567FFMPEG -r 10 -i ./image_%04d.jpg -s 640x640 -b 10M -vcodec mpeg4 ./video.mp4FFMPEG -r 10 -i ./image_%04d.jpg -s 640x640 -b 10M -vcodec mpeg4 ./video.mp4 制作模糊背景算法的机制应该是高斯模糊，但是作者还没有详细的检查对应的原理，能用就行。 此代码适合在横屏视频和竖屏视频之间的转换，并且填充一部分模糊的背景，不至于让视频有黑边而显的突兀参数说明，根据源视频生成两个视频，再将两个视频叠加，生成的高斯模糊的视频在原视频的下方同步播放，这样就实现了模糊式的视频视频 1234# -i 视频输出 -vf 参数转换 output.mp4 输出视频# -vf 内部参数说明：生成 1,2 两个视频。第一个视频是模糊背景，一般要放大一点， 使用 scale 来调整尺寸大小，第二个原视频不要动，overlay 合成并且调整源视频在高斯模糊背景中的视频的坐标ffmpeg -i input.mp4 -vf "split[a][b];[a]scale=1920:1920,boxblur=10:5[1];[b]scale=iw/ih[2];[1][2]overlay=(W-w)/2:y=(H-h)/2" output.mp4 效果如下： 原视频截图： 生成模糊背景之后的视频截图： 参考链接 ffmpeg 官方教程 偶遇FFmpeg(二)——常用命令 ~]]></content>
      <tags>
        <tag>视频</tag>
        <tag>FFmpeg</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 和 Linux 下执行命令行命令时如何换行]]></title>
    <url>%2FWindows%20%E5%92%8C%20Linux%20%E4%B8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E5%A6%82%E4%BD%95%E6%8D%A2%E8%A1%8C.html</url>
    <content type="text"><![CDATA[注意，如果命令需要换行，请添加换行字符 windows 为 “^”和 “`”，linux 为 “\” 12# 不换行ffmpeg -i ./input.mp4 -vcodec copy -acodec copy -ss 00:00:10 -to 00:00:15 ./cut01.mp4 -y 12345678# linux 环境ffmpeg -i ./output.mp4 \ -vcodec copy \ -acodec copy \ -ss 00:00:10 -to 00:00:15 \ ./cutout1.mp4 \ -y 123456789101112131415# windows CMD环境ffmpeg -i ./output.mp4 -vcodec copy ^ -acodec copy ^ -ss 00:00:10 ^ -to 00:00:15 ^ ./cutout1.mp4 ^ -y# windows Powershell环境ffmpeg -i ./output.mp4 -vcodec copy ` -acodec copy ` -ss 00:00:10 ` -to 00:00:15 ` ./cutout1.mp4 ` -y ~]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假如流浪地球计划失败，地球被木星捕获后会怎样？]]></title>
    <url>%2F%E5%81%87%E5%A6%82%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83%E8%AE%A1%E5%88%92%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%9C%B0%E7%90%83%E8%A2%AB%E6%9C%A8%E6%98%9F%E6%8D%95%E8%8E%B7%E5%90%8E%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F.html</url>
    <content type="text"><![CDATA[假如流浪地球计划失败，地球被木星捕获后会怎样？ 木星已经有79个的卫星，会对地球产生什么影响？ 我们的天空会是什么样子？ 地球在木星轨道能坚持多久？木星的超强引力会如何影响我们的生活？ document.getElementById('bilibili').setAttribute("style","width:100%"); document.getElementById('bilibili').style.minHeight='200px'; if (window.screen.height >window.screen.width) { document.getElementById('bilibili').style.height=window.screen.height / 4 + 'px'; } else { document.getElementById('bilibili').style.height=window.screen.height / 2 + 'px'; } Tips：点击视频右上角的去Bilibili观看，可以查看高清 1080P 源视频 ~~~]]></content>
      <tags>
        <tag>视频</tag>
        <tag>科普</tag>
        <tag>假如（WhatIF）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你最舍不得删的一段视频是什么？]]></title>
    <url>%2F%E4%BD%A0%E6%9C%80%E8%88%8D%E4%B8%8D%E5%BE%97%E5%88%A0%E7%9A%84%E4%B8%80%E6%AE%B5%E8%A7%86%E9%A2%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html</url>
    <content type="text"><![CDATA[这个黑人小孩！ your browser does not support the video tag 视频源自知乎： 你手机中最舍不得删的一段视频是什么？ Tips：推荐使用 Chrome 浏览器观看！ ~~~]]></content>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 在 windows 下的常用命令]]></title>
    <url>%2FNginx%20%E5%9C%A8%20windows%20%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Windows 下安装 Nginx 推荐使用绿色安装的方式，在 Nginx 官网下载安装包，直接解压压缩文件就可以了。安装成功后，进入 Nginx 文件夹的安装目录，Ctrl + 鼠标右键 打开 CMD 或者 Powershell 窗口即可。打开的窗口一般如下图所示： 1. 启动 Nginx执行以下命令，启动成功后打开浏览器输入 127.0.0.1 or localhost 访问 12345# 第一种方法，nginx在前台运行，关闭当前命令行窗口时 nginx 自动关闭PS D:\Program Files\nginx-1.13.7&gt; ./nginx.exe# 后台运行 nginxPS D:\Program Files\nginx-1.13.7&gt; start nginx 2. 关闭 Nginx123PS D:\Program Files\nginx-1.13.7&gt; ./nginx.exe -s stopPS D:\Program Files\nginx-1.13.7&gt; ./nginx.exe -s quit 注：stop是快速停止 Nginx，可能并不保存相关信息；quit是完整有序的停止 Nginx，并保存相关信息。 3、重新载入 Nginx12# 当配置信息修改，需要重新载入这些配置时使用此命令。PS D:\Program Files\nginx-1.13.7&gt; ./nginx.exe -s reload 4、查看 Nginx 版本：1PS D:\Program Files\nginx-1.13.7&gt; ./nginx.exe -v ~~~]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode176. 第二高的薪水]]></title>
    <url>%2Fleetcode176.html</url>
    <content type="text"><![CDATA[问题连接：196. 删除重复的电子邮箱 Question:编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小的那个。 1234567+----+------------------+| Id | Email |+----+------------------+| 1 | john@example.com || 2 | bob@example.com || 3 | john@example.com |+----+------------------+ Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: 123456+----+------------------+| Id | Email |+----+------------------+| 1 | john@example.com || 2 | bob@example.com |+----+------------------+ Answer:123456789101112-- 1. 查询第二高的薪水，说明查询结果要按照薪水降序排列 order by salary desc-- 2. 因为只是查询第二高说明是要分页查询，查询排序中的一个，所以要用到 limit 1 offset 0-- 3. 表中如果只有一条记录，则查询结果为空，但是题目要求的结果是返回 null，所有加上一个ifnull判断，如果返回为空，那么返回nullSELECT ifnull(( SELECT DISTINCT salary AS SecondHighestSalary FROM employee ORDER BY salary DESC LIMIT 1, 1 ), NULL) AS SecondHighestSalary ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode196. 删除重复的电子邮箱]]></title>
    <url>%2Fleetcode196.html</url>
    <content type="text"><![CDATA[问题连接：176. 第二高的薪水 Question:编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ SQL 架构：1234Create table If Not Exists Employee (Id int, Salary int) Truncate table Employeeinsert into Employee (Id, Salary) values (&apos;1&apos;, &apos;100&apos;)insert into Employee (Id, Salary) values (&apos;2&apos;, &apos;200&apos;)insert into Employee (Id, Salary) values (&apos;3&apos;, &apos;300&apos;) Answer:12345678910-- 并集查询，查询时，生成 m * n 条记录，其中 m 和 n 分别为两个表的记录个数，效率非常低，不建议使用-- 查询要删除的记录-- SELECT * FROM person p1, person p2 where p1.email = p2.email and p1.id &gt; p2.id -- 删除一个表时不需要指定从那个表删除记录-- DELETE FROM person WHERE id = 3-- 但是如果是两个表，要显式的指定要删除那个表DELETE p1 FROM person p1, person p2 where p1.email = p2.email and p1.id &gt; p2.id ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode596. 超过5名学生的课]]></title>
    <url>%2Fleetcode596.html</url>
    <content type="text"><![CDATA[问题连接：596. 超过5名学生的课 Question:有一个courses 表 ，有: student (学生) 和 class (课程)。 请列出所有超过或等于5名学生的课。 例如,表:12345678910111213+---------+------------+| student | class |+---------+------------+| A | Math || B | English || C | Math || D | Biology || E | Math || F | Computer || G | Math || H | Math || I | Math |+---------+------------+ 应该输出: 12345+---------+| class |+---------+| Math |+---------+ Note:学生在每个课中不应被重复计算。 Answer:1234-- select class from (select class, count(class) as counts from courses group by class) as temp where counts &gt;= 5-- having 和 where 的区别要好好查一下select class from courses group by class having count(distinct student) &gt;=5 ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode183. 从不订购的客户]]></title>
    <url>%2Fleetcode183.html</url>
    <content type="text"><![CDATA[问题连接：183. 从不订购的客户 Question:某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表：12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表： 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回： 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ Answer:1234567891011121314151617181920-- 使用not in查询-- 查询客户表，并且用户 id 从没有在 order 中产生关联关系作为查询条件即可获得返回结果 -- select name as customers from customers where customers.id not in (select customerId from orders)-- 使用not exist查询-- not exist的查询过程如下-- setp00 select customers（先执行外查询）-- step01 select orders（执行子查询，检测子查询是否可以返回行，则返回true or false的标记位）-- step02 根据 id 比较 两张表，将子查询的每一行设置 true or false 的标记位-- | 1 | Joe | true-- | 2 | Henry | false-- | 3 | Sam | true-- | 4 | Max | false-- step03 true为exist，false为not exist，则根据not exist的规则返回外查询中的查询条件返回henry, maxselect name as customers from customerswhere not exists(select customerId from orders where customers.id = orders.customerId) ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode182. 查找重复的电子邮箱]]></title>
    <url>%2Fleetcode182.html</url>
    <content type="text"><![CDATA[问题连接：182. 查找重复的电子邮箱 Question:编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例： 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 根据以上输入，你的查询应返回以下结果： 12345+---------+| Email |+---------+| a@b.com |+---------+ Answer:1234567-- 聚合查询就是 count()，分组就是 group by，分组聚合查询就是根据条件来统计数据的数量信息select email from(select email, count(email) num from person GROUP BY email) as temp_tablewhere num &gt; 1 ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode197. 上升的温度]]></title>
    <url>%2Fleetcode197.html</url>
    <content type="text"><![CDATA[问题连接：197. 上升的温度 Question:给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。12345678+---------+------------------+------------------+| Id(INT) | RecordDate(DATE) | Temperature(INT) |+---------+------------------+------------------+| 1 | 2015-01-01 | 10 || 2 | 2015-01-02 | 25 || 3 | 2015-01-03 | 20 || 4 | 2015-01-04 | 30 |+---------+------------------+------------------+ 例如，根据上述给定的 Weather 表格，返回如下 Id: 123456+----+| Id |+----+| 2 || 4 |+----+ Answer:12345678-- 主要使用到数据库自带的 DATEDIFF函数，当前表的级联我们可以使用默认的 inner join 获得两个数据的并集-- 此处使用 outer join 会报错，回头应该检查一下select w1.id from weather w1 inner join weather w2 where DATEDIFF(w1.RecordDate, w2.RecordDate) = 1 and w1.temperature &gt; w2.temperature ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode627. 交换工资]]></title>
    <url>%2Fleetcode627.html</url>
    <content type="text"><![CDATA[问题连接：627. 交换工资 Question:给定一个 salary 表，如下所示，有 m=男性 和 f=女性 的值 。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求使用一个更新（Update）语句，并且没有中间临时表。 请注意，你必须编写一个 Update 语句，不要编写任何 Select 语句。 例如: 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | m | 2500 || 2 | B | f | 1500 || 3 | C | m | 5500 || 4 | D | f | 500 | 运行你所编写的更新语句之后，将会得到以下表: 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | f | 2500 || 2 | B | m | 1500 || 3 | C | f | 5500 || 4 | D | m | 500 | Answer:12345678-- mysql case when 条件流程控制语句，case when 可以在查询修改等条件语句中用update salaryset sex = case sex when 'm' then 'f' else 'm'end; ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode181. 超过经理收入的员工]]></title>
    <url>%2Fleetcode181.html</url>
    <content type="text"><![CDATA[问题连接：181. 超过经理收入的员工 Question:Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 12345+----------+| Employee |+----------+| Joe |+----------+ Answer:12345678-- 员工表自我连接查询，并且找出满足对应薪水关系的员工SELECT name as employee FROM(select em.id, em.name, em.salary, em.ManagerId , manager.salary as salary1 FROM employee em JOIN employee as manager where em.ManagerId = manager.id and em.salary &gt; manager.salary) as temp ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode620. 有趣的电影]]></title>
    <url>%2Fleetcode620.html</url>
    <content type="text"><![CDATA[问题连接：620. 有趣的电影 Question:某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。 作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。 例如，下表 cinema: 123456789+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 1 | War | great 3D | 8.9 || 2 | Science | fiction | 8.5 || 3 | irish | boring | 6.2 || 4 | Ice song | Fantacy | 8.6 || 5 | House card| Interesting| 9.1 |+---------+-----------+--------------+-----------+ 对于上面的例子，则正确的输出是为： 123456+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 5 | House card| Interesting| 9.1 || 1 | War | great 3D | 8.9 |+---------+-----------+--------------+-----------+ Answer:123456-- 条件查询，排序select * from cinema where cinema.description != 'boring' and cinema.id % 2 = 1 order by cinema.rating desc ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode595. 大的国家]]></title>
    <url>%2Fleetcode595.html</url>
    <content type="text"><![CDATA[问题连接：595. 大的国家 Question:这里有张 World 表 123456789+-----------------+------------+------------+--------------+---------------+| name | continent | area | population | gdp |+-----------------+------------+------------+--------------+---------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000 || Albania | Europe | 28748 | 2831741 | 12960000 || Algeria | Africa | 2381741 | 37100000 | 188681000 || Andorra | Europe | 468 | 78115 | 3712000 || Angola | Africa | 1246700 | 20609294 | 100990000 |+-----------------+------------+------------+--------------+---------------+ 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。 编写一个SQL查询，输出表中所有大国家的名称、人口和面积。 例如，根据上表，我们应该输出: 123456+--------------+-------------+--------------+| name | population | area |+--------------+-------------+--------------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+--------------+-------------+--------------+ Answer:12-- 单纯的 where 条件查询select w.name, w.population, w.area from world w where w.area &gt; 3000000 or w.population &gt; 25000000 ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode175. 组合两个表]]></title>
    <url>%2Fleetcode175.html</url>
    <content type="text"><![CDATA[问题连接：175. 组合两个表 Question:表1: Person 12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键 表2: Address 123456789+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： 1FirstName, LastName, City, State Answer:12345678910# outer join 和 inner join 的区别# 为什么默认的是 inner join# 参考文章地址 https://www.cnblogs.com/toSeeMyDream/p/6843984.htmlselect Person.FirstName, Person.LastName, Address.City, Address.State from Personleft join Addresson Person.PersonId = Address.PersonId; ~~~]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[单例模式的集中实现方式： 懒汉式 lazyLoading，线程不安全 懒汉线程安全 同时满足效率低 饿汉式 最简单，最值得使用 threadSafe 登记式/内部静态类的方法 threadSafe lazyLoading 同时满足 没写的双重锁和枚举 12345678910111213141516171819202122232425/** * 饿汉式 * 懒加载初始化：false * 多线程安全： true * 实现简单程度：易 * * 优点：类加载时实例化对象，实现方式简单，并且没有多线程的安全性问题， * 缺点：就是在类加载的时候就实例化了对象，不管是否使用都会占用内存，但是如果没有特别明确的需求建议使用此种方法 * */public class Singleton &#123; private static Singleton single = new Singleton(); private Singleton()&#123;&#125; public static Singleton getSingleton () &#123; return single; &#125; public void hello() &#123; System.out.println("hello,world"); &#125;&#125; 123456789101112131415161718192021222324252627282930/** * 懒汉式 * 懒加载初始化：true * 多线程安全： false * 实现简单程度：易 * * 优点：实现方式简单，实现了lazyloading * 缺点：线程不安全，不支持多线程。没有加锁synchronized。严格意义不算是单利模式 * * 课后作业：测试一下多线程下的安全问题是如何出现的 * */public class SingletonLazyThreadUnsafe &#123; private static SingletonLazyThreadUnsafe single; private SingletonLazyThreadUnsafe()&#123;&#125; public static SingletonLazyThreadUnsafe getSingleton () &#123; if (single == null) &#123; return new SingletonLazyThreadUnsafe(); &#125; return single; &#125; public void hello() &#123; System.out.println("hello,world"); &#125;&#125; 12345678910111213141516171819202122232425262728/** * 懒汉式线程安全版 * 懒加载初始化：true * 多线程安全： true * 实现简单程度：易 * * 优点：实现方式简单，实现了lazyloading，可以在多线程中工作，但是效率很低，大概率情况下不需要同步 * 缺点：加锁 synchronized 才能保证运行，并且项目对getInstance的效率要求并不是很高 * */public class SingletonLazyThredSafe &#123; private static SingletonLazyThredSafe single; private SingletonLazyThredSafe()&#123;&#125; public static synchronized SingletonLazyThredSafe getSingleton () &#123; if (single == null) &#123; return new SingletonLazyThredSafe(); &#125; return single; &#125; public void hello() &#123; System.out.println("hello,world"); &#125;&#125; 12345678910111213141516171819202122232425262728/** * 登记式/静态内部类 * 懒加载初始化：true * 多线程安全： true * 实现简单程度：中 * * 优点：lazyloading，threadSafe * 缺点：加锁 synchronized 才能保证运行，并且项目对getInstance的效率要求并不是很高 * * 描述：同样使用类加载机制保证初始化instance时，只有一个线程。在实现线程安全的同时，实现了懒加载，更加节省了资源 */public class SingletonLazyInnerClass &#123; public static class SingletonHolder &#123; private static SingletonLazyInnerClass single = new SingletonLazyInnerClass(); &#125; private SingletonLazyInnerClass()&#123;&#125; public static SingletonLazyInnerClass getSingleton () &#123; return SingletonHolder.single; &#125; public void hello() &#123; System.out.println("hello,world"); &#125;&#125; 调用示例 12345678public class Main &#123; public static void main(String[] args) &#123; Singleton single = Singleton.getSingleton(); single.hello(); &#125;&#125; ~~~]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“知否精选”，小程序版本知乎日报诞生笔记]]></title>
    <url>%2F%E2%80%9C%E7%9F%A5%E5%90%A6%E7%B2%BE%E9%80%89%E2%80%9D%EF%BC%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5%E8%AF%9E%E7%94%9F%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[0. 引子Question: 为什么要小程序版本的“知乎日报”？ Answer: 国内大部分成熟的应用一般都会有对应的小程序版本的客户单，但是“知乎日报”没有。而我自己是非常喜欢小程序的，索性就自己做一个。 至于知乎官方为什么不实现这个小程序客户端我也不得而知，我通过在微信公众号后台查询得知 “知乎日报”这个名字的小城是已经被注册了，如下图： 根据现在的微信小程序名称命名的审核规则，像“知乎日报”这样名称的小程序主体一定是在知乎官方手中的。 总之，不管怎么说，既然知乎官方没有做，那么我就来做一个吧。 1. 关于知否精选本项目的初始版本已经正式发布在微信小程序，名称为 “知否精选”（官方名称知乎日报已经被注册，所以选择了这么一个名字）。除此之外，本项目的源代码也已经开源，源代码非常的简单，可以供想要学习小程序的同学们参考练手，地址如下： llyer/wechat-app-zhihudaily​在开始实现之前，我在网站搜索了一下，找到了知乎日报的 API，仓库的地址在下面 izzyleung/ZhihuDailyPurify API 的地址有了，接下来就是代码，同样在 github 上已经有了知乎日报的小程序版本代码，但是已经很久没有更新了，而且之前的作者也在仓库里面表示不再更新，仓库地址如下 myronliu347/wechat-app-zhihudaily 知否精选的主要资料来源如上。 2. 目前实现的功能1. 加载文章列表 ![](https://blog-1251468774.cos.ap-shanghai.myqcloud.com/20190314_知否精选_02.png) 2. 查看文章内容 ![](https://blog-1251468774.cos.ap-shanghai.myqcloud.com/20190314_知否精选_03.png) 这两个功能是知乎日报最核心的功能，都已经实现。当然在发开过程中也遇到了一些问题，目前已经有了一些已知的 BUG，也正在紧急修复中。例如知乎的API中返回的文章内容是富文本格式的，部分文章的格式解析可能没有做到完全的适配。如果对于本项目感兴趣的同学可以到 https://github.com/llyer/wechat-app-zhihudaily 点个 Star，如果发现了有什么问题，欢迎提 Issue。 如果你只是单纯的喜欢这个小程序版本的知乎日报。请在微信小程序搜索 “知否精选”即可打开本程序，或者使用扫描下方二维码打开 “知否精选”，如果遇到问题，请在下方留言告诉我，我会尽快解答。 ~~~]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode27. 移除元素]]></title>
    <url>%2Fleetcode27.html</url>
    <content type="text"><![CDATA[问题连接：27. 移除元素 123456789101112public class Solution &#123; public int removeElement(int[] nums, int val) &#123; //思路，将原来数组a所有不等于val的元素放到b中，返回新数组的长度 int j=0; for(int i=0;i&lt;nums.length;++i)&#123; if(nums[i]!=val)&#123; nums[j++]=nums[i]; &#125; &#125; return j; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode26. 删除排序数组中的重复项]]></title>
    <url>%2Fleetcode26.html</url>
    <content type="text"><![CDATA[问题连接：26. 删除排序数组中的重复项 12345678910111213class Solution &#123; public static int removeDuplicates(int[] nums) &#123; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i+1; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode21. 合并两个有序链表]]></title>
    <url>%2Fleetcode21.html</url>
    <content type="text"><![CDATA[问题连接：21. 合并两个有序链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) return null; ListNode result; if (l1 == null) &#123; result = l2; l2 = l2.next; &#125; else if (l2 == null) &#123; result = l1; l1 = l1.next; &#125; else if (l1.val &gt;= l2.val) &#123; result = l2; l2 = l2.next; &#125; else &#123; result = l1; l1 = l1.next; &#125; ListNode head = result; while (!(l1 == null &amp;&amp; l2 == null)) &#123; System.out.println("aaa"); if (l1 == null) &#123; head.next = l2; l2 = null; &#125; else if (l2 == null) &#123; head.next = l1; l1 = null; &#125; else if (l1.val &gt;= l2.val) &#123; head.next = l2; head = head.next; l2 = l2.next; &#125; else &#123; head.next = l1; head = head.next; l1 = l1.next; &#125; &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode20. 有效的括号]]></title>
    <url>%2Fleetcode20.html</url>
    <content type="text"><![CDATA[问题连接：20. 有效的括号 12345678910111213141516171819202122232425262728293031class Solution &#123; /** * * 这道题完美契合栈的所有特点，使用栈可以直接匹配解决 * * @param s * @return */ public static boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack(); char[] chars = s.toCharArray(); for (char c: chars) &#123; if (stack.size() &gt; 0) &#123; if (c == '&#125;' &amp;&amp; stack.peek() == '&#123;') &#123; stack.pop(); continue; &#125; if (c == ']' &amp;&amp; stack.peek() == '[') &#123; stack.pop(); continue; &#125; if (c == ')' &amp;&amp; stack.peek() == '(') &#123; stack.pop(); continue; &#125; &#125; stack.push(c); &#125; return stack.size() == 0 ? true : false; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode14. 最长公共前缀]]></title>
    <url>%2Fleetcode14.html</url>
    <content type="text"><![CDATA[问题连接：14. 最长公共前缀 12345678910111213141516class Solution &#123; public static String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return ""; // 遍历字符串，按顺序获取每个字符 for (int i = 0; i &lt; strs[0].length(); i++) &#123; // 根据当前字符遍历剩余的所有字符串 for (int j = 1; j &lt; strs.length; j++) &#123; if (strs[j].length() == i || strs[0].charAt(i) != strs[j].charAt(i)) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0]; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode13. 罗马数字转整数]]></title>
    <url>%2Fleetcode13.html</url>
    <content type="text"><![CDATA[问题连接：13. 罗马数字转整数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public static int romanToInt(String s) &#123; int result = 0; char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] == 'I') &#123; if ((i + 1) &lt; chars.length &amp;&amp; chars[i + 1] == 'V') &#123; result += 4; i++; continue; &#125; else if ((i + 1) &lt; chars.length &amp;&amp; chars[i + 1] == 'X') &#123; result += 9; i++; continue; &#125; result += 1; &#125; if (chars[i] == 'X') &#123; if ((i + 1) &lt; chars.length &amp;&amp; chars[i + 1] == 'L') &#123; result += 40; i++; continue; &#125; else if ((i + 1) &lt; chars.length &amp;&amp; chars[i + 1] == 'C') &#123; result += 90; i++; continue; &#125; result += 10; &#125; if (chars[i] == 'C') &#123; if ((i + 1) &lt; chars.length &amp;&amp; chars[i + 1] == 'D') &#123; result += 400; i++; continue; &#125; else if ((i + 1) &lt; chars.length &amp;&amp; chars[i + 1] == 'M') &#123; result += 900; i++; continue; &#125; result += 100; &#125; if (chars[i] == 'V') result += 5; if (chars[i] == 'L') result += 50; if (chars[i] == 'D') result += 500; if (chars[i] == 'M') result += 1000; &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode9. 回文数]]></title>
    <url>%2Fleetcode9.html</url>
    <content type="text"><![CDATA[问题连接：9. 回文数 123456789101112131415161718192021222324class Solution &#123; /** * 判断一个整数是否是回文数字 121，12321是，123 1234不是 * * @param x * @return */ public static boolean isPalindrome(int x) &#123; int origin = x; int result = 0; if (x &lt; 0) return false; // 123 while (x &gt; 0) &#123; int temp = x % 10; x = x / 10; result = result * 10 + temp; &#125; if (result == origin) return true; return false; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode7. 整数反转]]></title>
    <url>%2Fleetcode7.html</url>
    <content type="text"><![CDATA[问题连接：7. 整数反转 123456789101112131415class Solution &#123; public static int reverse(int x) &#123; int result = 0; // 当 x = 0 时，证明最后一位被处理完成，处理结束 while (x != 0) &#123; int pop = x % 10; x = x / 10; // 要在可能会发生溢出的操作前，对溢出进行判断 if (result &gt; Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE &amp;&amp; pop &gt; 7)) return 0; if (result &lt; Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE &amp;&amp; pop &lt; -8)) return 0; result = result * 10 + pop; &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode1. 两数之和]]></title>
    <url>%2Fleetcode1.html</url>
    <content type="text"><![CDATA[问题连接：1. 两数之和 1234567891011121314151617181920212223class Solution &#123; /** * nums 是一个数组，target 是结果，数组里面必定存在两个数字加起来等于 target * * @param nums * @param target * @return */ public static int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; // 遍历数字的所有加法组合 for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; result[0] = i; result[1] = j; return result; &#125; &#125; &#125; return null; &#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李鲁杨的个人简历]]></title>
    <url>%2F%E6%9D%8E%E9%B2%81%E6%9D%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.html</url>
    <content type="text"><![CDATA[个人资料 姓名：李鲁杨 性别：男 出生：1992-05 坐标：广东省深圳市 学位：本科 邮箱：392439022@qq.com 求职意向：研发工程师（Java，前端） 教育背景河南城建学院 计算机与数据科学学院 软件工程 主修课程数据结构，操作系统，计算机网络，Linux 操作系统，数据库，编译原理，C，C++， JavaSE ，JavaEE，HTML，CSS，JS，计算机组成原理，软件工程，软件过程和质量控制 在校经历 学习：各学科基础知识掌握良好，专业课优秀，无挂科，英语：CET-4 工作：院学生会副主席，体育部部长 证书：国家励志奖学金、二等、三等奖学金、优秀干部、三好学生等 个人技能Java: 熟悉面向对象，JavaSE，JavaEE 熟悉常用数据结构List, Set, Map 熟练Spring, Spring Boot, Spring Data JPA, Hibernate等技术 了解Spring Cloud，服务注册和发现，消费和治理等 了解JVM内核,常用设计模 数据库: 熟练：关系型数据库MySql 熟悉：Redis缓存数据库 前端： 熟练HTML，CSS，JS基础。包括语义化标签，盒模型理论等等 熟悉HTTP，TCP/IP，Web Socket 熟悉AngularJS，Vue，Node.js，NPM包管理工具 熟悉ES6新特性，模块化Module 熟悉AJAX，以及各种跨域配置CORS，本地代理（Webpack），Nginx反向代理 熟悉基于Vue的各种开源组件，Element UI等等（有阅读过部分组件源码） 熟悉GITHUB，在项目中有应用过相当多的开源组件 Echarts，quill等等 熟悉Markdown，Json 熟悉项目文档编写工作，团队文档管理工具Vue-press，docsify，swagger等 其他： 熟悉Linux，常用Ubuntu，CentOS 熟练Eclipse，IDEA，VSCODE，GIT，禅道，Chrome Dev Tool等常用开发和协同工具 熟悉VPS，翻墙，抓包等技能，极其擅长面向搜索编程 了解云计算，IaaS，PaaS，虚拟机，容器，语言运行环境，Docker，Kubernetes 等技术 都有涉猎 了解Apache JMeter 等压力测试工具 项目经历1. PaaS 云端应用平台描述： 我个人的主要工作内容在于基于开源 PaaS 层云计算平台 CF 的 Cloud Controller API 的二次封装。并且在这一层中间层实现业务逻辑。并且提供 Restful API 接口给前端，然后由前端实现可视化界面，方便对集群的控制。基于 Java 语言，CF SDK 和 CF Restful API。实现包括应用部署，应用查询和监控，应用伸缩，服务管理，路由和域名管理等等。 功能/收获： 提供标准的 Restful API和详细的Swagger 使用文档，所有业务功能提供基础的增删改查业务和复杂的条件，分页，搜索查询接口 应用部署，应用查询和监控，应用伸缩，负载均衡，服务发现，服务绑定等核心功能 实现QQ第三方登陆（熟悉 Oauth2.0，Openid等第三方登陆对接模式） 基于Socket.io的实施应用日志推送接口 用户校验，权限过滤，登陆日志，操作日志等系统常用功能的实现 技术栈： Spring 全家桶，Cf-client 客户端工具，数据库为Mysql 内置邮件服务，用户邮箱注册校验，登陆图形验证码 SHA1登陆加密，保证账户安全 压力测试工具 符合云原生应用标准，提高并发，直接拷贝多实例部署负载均衡即可满足要求 2. PaaS 云端应用平台（前端）描述： 独立开发，此项目经历了 JQUERY &gt; Angular 1.x &gt; Vue 2.x 的迭代，项目的重构主要优化了代码的质量和可读性。前端工程化，码模块化的问题也通过引入 Webpack，ES6的模块化。其他方面和后台使用 Ajax 交互Json 数据。采用VSCODE开发，使用了GIT作为版本控制工具。 功能/收获： 为PaaS云应用管理平台提供可视化用户界面 作为项目主站，提供宣传Feature 等页面宣传公司的产品 技术栈： 核心框架有Webpack, Vue2.x, Vuex, Vue-router, Axios, echarts 常用工具类库有 lodash, Jsencrypt 用户信息加密，moment.js, marked，highlight.js 文档高亮格式化, normalize.css初始化样式表， 等等 组件相关的有富文本处理组件 quill, swiper, vivus.js, cropper.js, distpicker日期选择器，particles.js，animate.css页面动画处理，element-ui组件库 3. 用户认证和权限管理系统描述：公司内部综合运营管理系统主站点的用户管理系统。主要是一套基于角色的访问控制(RBAC)系统，提供校验和权限服务，细粒度到 API 层面的权限控制，以及提供接口给前台主站和其他的关联后台应用（合同管理系统）调用等等。 技术栈： Java代码层面主要有Spring Boot, Spring Security, Web, JPA, JWT Token, Swagger 数据库层面主要有Mysql，包含了用户，角色，权限等表来对项目进行权限控制 功能/收获： 登陆校验，用户管理，权限管理，角色管理 接口数据校验，登陆和权限校验，统一异常处理，统一格式化返回数据等功能 4. 邮件系统描述：主要提供了各种各样的邮件 API 和定制的邮件模板来提供邮件服务，除此之外还包含定时任务处理邮件通知功能，例如用户余不足推送通知给用户。提供各种接口，支持附件，抄送，富文本，定制模板等等。 技术栈： Spring Boot, Spring Security, Web, JPA, Mail 功能/收获： 多种复杂邮件发送接口和各个项目定制邮件接口的实现 邮件相关的定时任务的处理 5. 综合运营系统描述：公司后台管理系统主站点。后台包括用户权限系统，计费系统，合同管理系统，邮件管理系统，用户资源管理系统，实现了公司各个主要服务的可视化界面展示，主要用户为公司内部员工，运维和销售等等。 技术栈： 核心框架有Webpack, Vue2.x, Vuex, Vue-router, Axios, echarts 功能/收获： 用户管理，权限管理，用户机时管理，用户资源管理，账单统计等等 前端依据用户的角色和权限动态生成菜单和对应的界面 报表生成功能，页面统计用户数据，转换格式，发送到用户邮箱 用户信用额度审批，资源审批 6. 橘子文库项目描述：主要实现类似百度文库的文档管理和预览功能。格式转换+Flash 插件预览模拟模仿实现百度文库。核心业务是用户上传 DOC、PDF 等办公文件到服务器，服务器调用文件转换功能将办公文件转换成 SWF 格式文件，前端用 Flash 渲染给用户，即可实时览文档的内容。（非商业项目） 技术栈： JSP、SERVLET、MYSQL、OpenOffice 功能/收获： 文档管理，增删改查，下载 文档预览，基于OpenOffice 工作经历2016-11~ 今 北京并行科技股份有限公司 研发工程师（Java方向，前端） 工作内容在于基于集群的 Cloud Controller API 的二次封装。并且在这一层中间层实现业务逻辑。并且提供 Restful API 接口前端，然后由前端实现可视化界面，方便对集群的控制。 2016-06 ~ 2016-11 深圳市友能网络科技有限公司 研发工程师（Java 方向） 个人在公司主要负责公司EPG业务的开发和维护，例如游戏大厅，短期活动等产品，主要使用的技术也在mysql+java+HTML+CSS+JS这一块，由于前端产品（基于IPTV机顶盒开发）的特殊性，前端技术主要都以原生技术为主。以及linux下的项目部署和维护。 自我评价计算机科学软件工程专业毕业，专业基础知识扎实。本科期间受到过良好的软件过程和软件工程思想教育。有良好的逻辑思维能力，语言表达能力，良好的计算机思维，问题定位的能力和解决问题的专业技术能力。除此之外还有优秀的自我驱动能力，学习，记录笔记的习惯。 热爱技术，创造有价值的东西。 ~~~]]></content>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 学习笔记一：安装和配置]]></title>
    <url>%2FJenkins%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[下载 jenkins官方下载地址：https://jenkins.io/zh/download/ 上图中我们可以看到 jenkins 的版本信息（推荐 LTS 版本）和各种平台下的安装方法。下面我们举例在 Ubuntu 系统中用 apt 安装（CentOS 下使用 yum）和 war 包两种方式。 apt 安装我们以 Ubuntu16.04 为例，打开 https://pkg.jenkins.io/debian-stable/ 获取 Key 1wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - 修改软件包 deb 下载地址 12345# 修改 apt sources 文件vim /etc/apt/sources.list# 添加下面记录deb https://pkg.jenkins.io/debian-stable binary/# 保存并且推出 更新 apt 1sudo apt-get update 下载 jenkins 1sudo apt-get install jenkins jenkins 默认启动端口为 8080，打开浏览器访问 http://localhost:8080 War 包安装下载 JDK8.0，将 War 包拷贝到服务器，执行 java -jar 命令运行 1234# 启动 jenkinsjava -jar jenkins.war# 启动并且指定端口java -jar jenkins.war --httpPort=9090 Docker 安装按照官方教程参考地址： https://jenkins.io/doc/book/installing/ 注意：最新版的 jenkins 安装启动后默认已经支持汉语，Jenkins 部署成功后额配置按照提示设置用户和密码，安装默认插件即可 配置一些快捷操作 Url以基础地址为：http://localhost:8080/ 举例 关闭：http://localhost:8080/exit 重启：http://localhost:8080/restart 重新加载配置：http://localhost:8080/reload 界面如下图所示： ~~~]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes 的 Web 客户端 kubernetes-dashboard 安装教程]]></title>
    <url>%2FKubernetes%20%E7%9A%84%20Web%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20kubernetes-dashboard%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[在kubernetes集群中安装dashboard插件准备工作在之前我们已经成功部署了一个简单的Kubernete测试集群，接下来我们要来安装Dashboard插件，Dashboard是一个基于Web的Kubernetes用户界面。在安装之前呢我们首先要检查一下 Kubernetes 和 Dashboard 的兼容性 Dashboard \ Kubernetes 1.4 1.5 1.6 1.7 1.8 1.9 1.4 ✓ ✕ ✕ ✕ ✕ ✕ 1.5 ✕ ✓ ✕ ✕ ✕ ✕ 1.6 ✕ ✕ ✓ ? ✕ ✕ 1.7 ✕ ✕ ? ✓ ? ? 1.8 ✕ ✕ ✕ ✕ ✓ ✓ HEAD ✕ ✕ ✕ ✕ ✓ ✓ ✓ 支持的版本 ? 由于突破了Kubernetes API版本之间的变化，某些功能可能无法在 Dashboard（日志，搜索等）中使用。 ✕ 不支持的版本 官网wiki地址：Dashboard 和 Kubernetes 的兼容性矩阵 下载镜像，修改镜像名称根据上个表格的兼容性可知，我们之前部署的 Kubernetes 版本为1.9.1，所有我们可是使用的 Dashboard 版本为 1.8 以上。执行以下命令下载镜像 123docker pull liluyang/kubernetes-dashboard-amd64:latestdocker tag liluyang/kubernetes-dashboard-amd64:latest k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3docker rmi liluyang/kubernetes-dashboard-amd64:latest 安装 Dashboard将文件 kubernetes-dashboard.yaml 下载到本地，执行以下命令安装 Dashboard 1234567891011121314151617# kubectl create -f kubernetes-dashboard.yamlsecret "kubernetes-dashboard-certs" createdserviceaccount "kubernetes-dashboard" createdrole.rbac.authorization.k8s.io "kubernetes-dashboard-minimal" createdrolebinding.rbac.authorization.k8s.io "kubernetes-dashboard-minimal" createddeployment.apps "kubernetes-dashboard" createdservice "kubernetes-dashboard" created# kubectl get pod -n kube-system -o wideNAME READY STATUS RESTARTS AGE IP NODEcanal-4n2tw 3/3 Running 0 2h 192.168.85.134 ubuntuetcd-ubuntu 1/1 Running 0 2h 192.168.85.134 ubuntukube-apiserver-ubuntu 1/1 Running 0 2h 192.168.85.134 ubuntukube-controller-manager-ubuntu 1/1 Running 0 2h 192.168.85.134 ubuntukube-dns-6f4fd4bdf-gpvh4 3/3 Running 0 2h 10.244.0.5 ubuntukube-proxy-kbdvk 1/1 Running 0 2h 192.168.85.134 ubuntukube-scheduler-ubuntu 1/1 Running 0 2h 192.168.85.134 ubuntukubernetes-dashboard-5bd6f767c7-cmvb4 1/1 Running 0 8s 10.244.0.6 ubuntu 执行成功后可以发现 dashboard 理论上已经安装成功了，接下来我们就需要验证一下 访问 dashboard 界面有多种方式可以访问仪表板 Dashboard UI; 可以使用kubectl命令行代理访问，也可以使用Web浏览器访问Kubernetes主apiserver。 命令行代理您可以通过运行以下命令使用kubectl命令行工具开启代理用来访问仪表板： 1kubectl proxy Kubectl将处理apiserver的身份验证，并使Dashboard在http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/ 链接中可以访问，如下图所示： 注意：Dashboard UI 只能从执行该命令的机器访问。执行kubectl proxy --help可以查看详细的使用方法。 直接访问 Master Server暴露服务的方式可以将 NodePort 映射到物理机的端口号，用于客户端浏览器的访问。在上面的 kubernetes-dashboard.yaml 文件中，我们已经将 Dashboard 的服务暴露了出来，具体的配置如下： 123456789101112131415161718# ------------------- Dashboard Service ------------------- ## 暴露服务到物理机端口号，使得服务可以从外部访问kind: ServiceapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemspec: type: NodePort ports: - port: 443 targetPort: 8443 nodePort: 30000 selector: k8s-app: kubernetes-dashboard 接下来我们使用火狐浏览器直接访问就可以了，输入 Master 节点的 IP 地址和对应的 NodePort 端口，例如 https://192.168.85.134:30000，就可以访问我们的 Dashboard 界面了。如下图所示： 注意浏览器地址和 kube proxy 方式访问时的地址是不同的。使用暴露服务的访问可以在任何主机上访问 Dashboard，只要满足网络可达的条件即可 身份认证登录dashboard 的时候支持Kubeconfig 和token 两种认证方式，Kubeconfig 中也依赖 token 字段，所以生成 token 这一步是必不可少的。 生成 Token我们创建一个admin用户并授予admin 角色绑定，使用下面的yaml文件创建admin用户并赋予他管理员权限，然后就可以通过token 登陆dashbaord，这种认证方式本质实际上是通过Service Account 的身份认证加上Bearer token请求 API server 的方式实现，参考 Kubernetes 中的认证。 1234567891011121314151617181920212223kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata: name: admin annotations: rbac.authorization.kubernetes.io/autoupdate: "true"roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.iosubjects:- kind: ServiceAccount name: admin namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata: name: admin namespace: kube-system labels: kubernetes.io/cluster-service: "true" addonmanager.kubernetes.io/mode: Reconcile 创建用户admin用户，关联cluster-admin角色，拥有极高的权限。查询该用户对应的token，具体的返回信息如下所示： 12345678# kubectl apply -f ./admin.yaml clusterrolebinding.rbac.authorization.k8s.io "admin" createdserviceaccount "admin" created# kubectl get secret -n kube-system|grep admin-tokenadmin-token-lvlzs kubernetes.io/service-account-token 3 37s# kubectl get secret admin-token-d5jsg -o jsonpath=&#123;.data.token&#125; -n kube-system |base64 -d# 会生成一串很长的base64后的字符串，复制这个 token 到浏览器进行登陆 然后在Dashboard登录页面上直接使用上面得到的 Token 字符串即可登录，这样就可以使用可视化界面操作整个kubernetes集群，如下图所示： 到此为止，我们的 Dashboard 插件已经安装成功，可以正常使用。 可能出现的问题如果在浏览器访问 Dashboard 的过程中出现以下问题 这是因为我们刚刚部署的集群并没有合适的证书所造成的问题，点击下面的 添加例外，信任即可。 参考链接 官方：Web UI (Dashboard) 简介 官方：Dashboard 和 Kubernetes 的兼容性矩阵]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 kubeadm 安装 kubernetes 的教程]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%20kubeadm%20%E5%AE%89%E8%A3%85%20kubernetes%20%E7%9A%84%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[使用kubeadm快速构建Kubernetes集群本文将介绍如何在 Ubuntu server 16.04 版本上安装 kubeadm，并利用 kubeadm 快速的在 Ubuntu Server 16.04 上构建一个 Kubernetes 的基础集群，用来做学习和测试用途等，当前（2018-06-26）最新的版本是 1.10.4。参考文档包括 Kubernetes 官方网站的 kubeadm 安装文档 以及 利用kubeadm创建集群 这两个文档。 生产用途的环境，需要考虑各个组件的高可用，建议参考 Kubernetes 的官方的相关的安装文档。 前置要求 熟悉基本的 Linux 操作 了解 Docker、容器技术等相关概念，有一定 Docker 命令使用经验 了解基础的网络概念 有一定的虚拟机使用经验，了解 vmware，xshell 等软件更好 准备工作Kubernetes 安装建议至少 2 台服务器或者虚拟机，每台服务器 4G 内存，2 个 CPU 核心以上，基本架构为 1 台 master 节点，1 台 Slave 节点。本次的整个安装过程将 vmware 虚拟机下的两台 Ubuntu server 16.04 服务器上，包括 kubeadm、Kubernetes、canal 网络的安装。节点信息如下: 角色 主机名 IP地址 Master ubuntu 192.168.85.134 Slave ubuntu-1 192.168.85.133 默认方式安装 Ubuntu Server 16.04 每个节点配置主机名映射 ::: warning 注意在集群的部署过程中一定要先修改两台主机的 hostname，防止主机重名。因为我们只有两台主机，所以我们将 Slave 节点的 主机名称修改为 ubuntu-1 即可，Master 节点的名称为 ubuntu 不变。::: 修改节点名称： 12345678# 在 slave 节点查看 hostname$ hostnameubuntu$ vi hostname# 编辑主机名称为 ubuntu-1，重启之后上校# 重启后查询主机名称$ hostnameubuntu-1 安装 Docker安装 Docker 可以使用系统源的的 docker.io 软件包，目前的版本 1.13.1，我的系统里是已经安装好最新的版本了。 目前（2018.06.26）Docker-CE 的最新版本已经更新到了 18.03.1-ce 以上，但是由于 Kubernetes 并没有对最新的 Docker 版本进行校验，所以可能会产生未知的问题。所以目前建议使用 apt-get 官方默认下载源的 docker.io 安装包。安装 1.13.1 的版本。 123456$ apt-get install docker.ioReading package lists... DoneBuilding dependency tree Reading state information... Donedocker.io is already the newest version (1.13.1-0ubuntu1~16.04.2).0 upgraded, 0 newly installed, 0 to remove and 210 not upgraded. Kubernetes 对 Docker 的版本支持列表如下所示： Kubernetes版本 Docker版本 Kubernetes 1.9 Docker 1.11.2 to 1.13.1 and 17.03.x Kubernetes 1.8 Docker 1.11.2 to 1.13.1 and 17.03.x Kubernetes 1.7 Docker 1.10.3, 1.11.2, 1.12.6 Kubernetes 1.6 Docker 1.10.3, 1.11.2, 1.12.6 Kubernetes 1.5 Docker 1.10.3, 1.11.2, 1.12.3 官方对于 Docker 支持列表的文档参考链接： Kubernetes 1.5: https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.5.md#external-dependency-version-information Kubernetes 1.6: https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.6.md#external-dependency-version-information Kubernetes 1.7: https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.7.md#external-dependency-version-information Kubernetes 1.8: https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.8.md#external-dependencies Kubernetes 1.9: https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.9.md#external-dependencies 在所有节点上安装 kubeadm查看 apt 安装源，并且修改安装源配置文件，添加如下配置，使用阿里云的系统和 Kubernetes 的源。 1234567891011$ cat /etc/apt/sources.list# 系统安装源deb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse# kubeadm及kubernetes组件安装源deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main 修改完成后更新下载源，忽略不理会 gpg 的警告信息。 123456789101112# apt-get updateHit:1 http://mirrors.aliyun.com/ubuntu xenial InReleaseHit:2 http://mirrors.aliyun.com/ubuntu xenial-updates InReleaseHit:3 http://mirrors.aliyun.com/ubuntu xenial-backports InReleaseGet:4 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial InRelease [8,993 B]Ign:4 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial InReleaseFetched 8,993 B in 0s (20.7 kB/s)Reading package lists... DoneW: GPG error: https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 6A030B21BA07F4FBW: The repository 'https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial InRelease' is not signed.N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.N: See apt-secure(8) manpage for repository creation and user configuration details. ::: warning 注意建议使用 Ubuntu 16.04 版本的系统。Ubuntu 18.04 的系统在进行这一步的更新下载源会失败。更新源的警告 Warning 会变成 Error 导致更新源不成功,无法使用 apt-get 包管理工具进行后续的 kubeadm 等软件的下载。::: 在 Ubuntu 18.04 系统中替代方法是可以使用 snap 包管理下载 kudeadm 等软件，然后修改环境变量 PATH,将 kubeadm 等软件的执行路径添加到其中即可，具体用法可以自行搜索。不过不依然建议使用这种方法。 使用 apt 强制安装 kubeadm，kubectl，kubelet 软件包。1234567891011121314151617181920212223242526272829# apt-get install -y kubelet kubeadm kubectl --allow-unauthenticatedReading package lists... DoneBuilding dependency treeReading state information... DoneThe following additional packages will be installed: kubernetes-cni socatThe following NEW packages will be installed: kubeadm kubectl kubelet kubernetes-cni socat0 upgraded, 5 newly installed, 0 to remove and 4 not upgraded.Need to get 56.9 MB of archives.After this operation, 410 MB of additional disk space will be used.WARNING: The following packages cannot be authenticated! kubernetes-cni kubelet kubectl kubeadmAuthentication warning overridden.Get:1 http://mirrors.aliyun.com/ubuntu xenial/universe amd64 socat amd64 1.7.3.1-1 [321 kB]Get:2 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubernetes-cni amd64 0.6.0-00 [5,910 kB]Get:3 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubelet amd64 1.10.1-00 [21.1 MB]Get:4 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubectl amd64 1.10.1-00 [8,906 kB]Get:5 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubeadm amd64 1.10.1-00 [20.7 MB]Fetched 56.9 MB in 5s (11.0 MB/s)Use of uninitialized value $_ in lc at /usr/share/perl5/Debconf/Template.pm line 287.Selecting previously unselected package kubernetes-cni.(Reading database ... 191799 files and directories currently installed.)Preparing to unpack .../kubernetes-cni_0.6.0-00_amd64.deb ...Unpacking kubernetes-cni (0.6.0-00) ...Selecting previously unselected package socat.Preparing to unpack .../socat_1.7.3.1-1_amd64.deb ...Unpacking ........ 由于演示代码安装的 kubernetes 的版本是 1.9.1，这对于最新版本的 kubeadm 来说是不兼容的，因此我们可以在下载 kubeadm 的过程中指定版本安装，下面的示例中我们安装的版本是 1.9.0。使用这个版本我们可以正常的安装 kubernetes 1.9.1。 1234567891011121314151617181920212223# apt-cache madison kubeadm kubeadm | 1.10.5-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages kubeadm | 1.10.4-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages ······ kubeadm | 1.9.1-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages kubeadm | 1.9.0-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages kubeadm | 1.8.14-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages ······ kubeadm | 1.6.2-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages kubeadm | 1.6.1-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages kubeadm | 1.5.7-00 | https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 Packages# apt-get install kubeadm=1.9.0-00Reading package lists... DoneBuilding dependency tree Reading state information... Donekubeadm is already the newest version (1.9.0-00).0 upgraded, 0 newly installed, 0 to remove and 209 not upgraded.# kubeadm versionkubeadm version: &amp;version.Info&#123;Major:"1", Minor:"9", GitVersion:"v1.9.0", GitCommit:"925c127ec6b946659ad0fd596fa959be43f0cc05", GitTreeState:"clean", BuildDate:"2017-12-15T20:55:30Z", GoVersion:"go1.9.2", Compiler:"gc", Platform:"linux/amd64"&#125; 到此为止，kubeadm 已经安装完成，我们可以使用它来快速安装部署 Kubernetes 集群了。 使用 kubeadm 安装 Kubernetes 集群下载安装 Docker 所需的镜像列表如果你的网络已经翻墙，那么跳过本节，直接进入下一节执行 kubeadm init 初始化 master 节点 在执行 kubeadm 命令时系统会自动访问 Google Cloud Platform 去下载安装 kubernetes 集群的核心镜像。但是由于 GFW 的原因，导致我们无法正常的访问 Google Cloud Platform，所以就需要换一种方法去下载镜像。这里叫大家一种下载镜像的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243echo 下载镜像docker pull xiaoyaolangzi/etcd-amd64:3.1.10docker pull xiaoyaolangzi/kube-apiserver-amd64:v1.9.1docker pull xiaoyaolangzi/kube-controller-manager-amd64:v1.9.1docker pull xiaoyaolangzi/kube-scheduler-amd64:v1.9.1docker pull xiaoyaolangzi/k8s-dns-dnsmasq-nanny-amd64:1.14.7docker pull xiaoyaolangzi/k8s-dns-kube-dns-amd64:1.14.7docker pull xiaoyaolangzi/k8s-dns-sidecar-amd64:1.14.7docker pull xiaoyaolangzi/kube-proxy-amd64:v1.9.1docker pull xiaoyaolangzi/pause-amd64:3.0docker pull xiaoyaolangzi/metrics-server-amd64:v0.2.0echo 修改标签docker tag xiaoyaolangzi/etcd-amd64:3.1.10 gcr.io/google_containers/etcd-amd64:3.1.10docker tag xiaoyaolangzi/kube-apiserver-amd64:v1.9.1 gcr.io/google_containers/kube-apiserver-amd64:v1.9.1docker tag xiaoyaolangzi/kube-controller-manager-amd64:v1.9.1 gcr.io/google_containers/kube-controller-manager-amd64:v1.9.1docker tag xiaoyaolangzi/kube-scheduler-amd64:v1.9.1 gcr.io/google_containers/kube-scheduler-amd64:v1.9.1docker tag xiaoyaolangzi/k8s-dns-dnsmasq-nanny-amd64:1.14.7 gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.7docker tag xiaoyaolangzi/k8s-dns-kube-dns-amd64:1.14.7 gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.7docker tag xiaoyaolangzi/k8s-dns-sidecar-amd64:1.14.7 gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.7docker tag xiaoyaolangzi/kube-proxy-amd64:v1.9.1 gcr.io/google_containers/kube-proxy-amd64:v1.9.1docker tag xiaoyaolangzi/pause-amd64:3.0 gcr.io/google_containers/pause-amd64:3.0docker tag xiaoyaolangzi/metrics-server-amd64:v0.2.0 gcr.io/google_containers/metrics-server-amd64:v0.2.0echo 删除镜像docker rmi xiaoyaolangzi/etcd-amd64:3.1.10docker rmi xiaoyaolangzi/kube-apiserver-amd64:v1.9.1docker rmi xiaoyaolangzi/kube-controller-manager-amd64:v1.9.1docker rmi xiaoyaolangzi/kube-scheduler-amd64:v1.9.1docker rmi xiaoyaolangzi/k8s-dns-dnsmasq-nanny-amd64:1.14.7docker rmi xiaoyaolangzi/k8s-dns-kube-dns-amd64:1.14.7docker rmi xiaoyaolangzi/k8s-dns-sidecar-amd64:1.14.7docker rmi xiaoyaolangzi/kube-proxy-amd64:v1.9.1docker rmi xiaoyaolangzi/pause-amd64:3.0docker rmi xiaoyaolangzi/metrics-server-amd64:v0.2.0 复制上面的脚本，新建一个 1.9.1.sh 的脚本，将内容复制进去，执行该脚本下载镜像 1234# 修改执行权限$ chmod 755 ./1.9.1.sh# 执行脚本$ ./1.9.1.sh 下载完成后使用查看下载完成的镜像列表，如果最后下载完成的镜像列表如下图所示，那么证明镜像列表已经下载成功了 123456789101112# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgcr.io/google_containers/metrics-server-amd64 v0.2.0 05ddb332f1ff 5 months ago 96.5 MBgcr.io/google_containers/pause-amd64 3.0 3773f3dd7d9b 5 months ago 747 kBgcr.io/google_containers/kube-scheduler-amd64 v1.9.1 7f4072f8640c 5 months ago 62.7 MBgcr.io/google_containers/kube-proxy-amd64 v1.9.1 d6b97770e509 5 months ago 109 MBgcr.io/google_containers/kube-controller-manager-amd64 v1.9.1 94e3348da21f 5 months ago 138 MBgcr.io/google_containers/kube-apiserver-amd64 v1.9.1 36589a515579 5 months ago 210 MBgcr.io/google_containers/k8s-dns-sidecar-amd64 1.14.7 da641877cb23 5 months ago 42 MBgcr.io/google_containers/k8s-dns-kube-dns-amd64 1.14.7 80db1c7f1052 5 months ago 50.3 MBgcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64 1.14.7 cdb0a2151300 5 months ago 41 MBgcr.io/google_containers/etcd-amd64 3.1.10 83e68e9d1d4a 5 months ago 193 MB 使用kubeadm初始化master节点因为使用要使用 canal，因此需要在初始化时加上网络配置参数,设置 kubernetes 的子网为 10.244.0.0/16，注意此处不要修改为其他地址，因为这个值与后续的 canal 的 yaml 值要一致，如果修改，请一并修改。 这个下载镜像的过程涉及翻墙，因为会从 gcr.io 的站点下载容器镜像。。。（如果大家翻墙不方便的话，请回头看上一个章节）。 如果有能够连接 gcr.io 站点的网络，那么整个安装过程非常简单，直接运行以下命令即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# kubeadm init --kubernetes-version=1.9.1 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.244.0.0/16[init] Using Kubernetes version: v1.9.1[init] Using Authorization modes: [Node RBAC][preflight] Running pre-flight checks. [WARNING FileExisting-crictl]: crictl not found in system path[preflight] Starting the kubelet service[certificates] Generated ca certificate and key.[certificates] Generated apiserver certificate and key.[certificates] apiserver serving cert is signed for DNS names [ubuntu kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.244.0.1 192.168.85.134][certificates] Generated apiserver-kubelet-client certificate and key.[certificates] Generated sa key and public key.[certificates] Generated front-proxy-ca certificate and key.[certificates] Generated front-proxy-client certificate and key.[certificates] Valid certificates and keys now exist in "/etc/kubernetes/pki"[kubeconfig] Wrote KubeConfig file to disk: "admin.conf"[kubeconfig] Wrote KubeConfig file to disk: "kubelet.conf"[kubeconfig] Wrote KubeConfig file to disk: "controller-manager.conf"[kubeconfig] Wrote KubeConfig file to disk: "scheduler.conf"[controlplane] Wrote Static Pod manifest for component kube-apiserver to "/etc/kubernetes/manifests/kube-apiserver.yaml"[controlplane] Wrote Static Pod manifest for component kube-controller-manager to "/etc/kubernetes/manifests/kube-controller-manager.yaml"[controlplane] Wrote Static Pod manifest for component kube-scheduler to "/etc/kubernetes/manifests/kube-scheduler.yaml"[etcd] Wrote Static Pod manifest for a local etcd instance to "/etc/kubernetes/manifests/etcd.yaml"[init] Waiting for the kubelet to boot up the control plane as Static Pods from directory "/etc/kubernetes/manifests".[init] This might take a minute or longer if the control plane images have to be pulled.[apiclient] All control plane components are healthy after 29.504162 seconds[uploadconfig] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace[markmaster] Will mark node ubuntu as master by adding a label and a taint[markmaster] Master ubuntu tainted and labelled with key/value: node-role.kubernetes.io/master=""[bootstraptoken] Using token: 7e9211.94f5426a55b22eb3[bootstraptoken] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstraptoken] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstraptoken] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstraptoken] Creating the "cluster-info" ConfigMap in the "kube-public" namespace[addons] Applied essential addon: kube-dns[addons] Applied essential addon: kube-proxyYour Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join --token 7e9211.94f5426a55b22eb3 192.168.85.134:6443 --discovery-token-ca-cert-hash sha256:cb009a5dde6b127d4844cffe04163a0ce07f10557cd0c2ccfa4c51eb5536ab02 执行如下命令来配置 kubectl。 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 这样 Master 的节点就配置好了，并且可以使用 kubectl 来进行各种操作了。 ::: warning 注意如果在部署过程中依然出现了卡在这一步的情况，那么可能是镜像包的名称没有修改正确，导致 kubeadm 无法找到安装 kubernetes 所需要的镜像，依然去 gcr.io 下载镜像，而我们的网络又没有翻墙，导致卡在这一步无法正常安装成功。::: 解决办法如下：在执行完成 kubeadm init 命令后，本地的文件系统中就生成了以下几个核心组件的配置文件，这几个配置文件中描述了需要使用的镜像的名称和版本。使用 cat 分别输出这四个文件的内容： 1234cat /etc/kubernetes/manifests/kube-apiserver.yamlcat /etc/kubernetes/manifests/kube-controller-manager.yamlcat /etc/kubernetes/manifests/kube-scheduler.yamlcat /etc/kubernetes/manifests/etcd.yaml 正常情况配置文件中的 yaml 文件中的 image 字段应该是 image: gcr.io/google_containers/kube-controller-manager-amd64:v1.9.1 等等这样的结构，但是之前我自己在部署的过程中遇到过一次需要下载的镜像名称不是这种格式而是 image: k8s.gcr.io/kube-controller-manager-amd64:v1.9.1，这个时候我们需要接着执行以下命令，修改镜像的名称 1234# docker tag gcr.io/google_containers/kube-apiserver-amd64:v1.9.1 k8s.gcr.io/kube-apiserver-amd64:v1.9.1# docker tag gcr.io/google_containers/kube-controller-manager-amd64:v1.9.1 k8s.gcr.io/kube-controller-manager-amd64:v1.9.1# docker tag gcr.io/google_containers/kube-scheduler-amd64:v1.9.1 k8s.gcr.io/kube-scheduler-amd64:v1.9.1# docker tag gcr.io/google_containers/etcd-amd64:3.1.12 k8s.gcr.io/etcd-amd64:3.1.12 修改完成之后，再次执行 kubeadm init 命令，稍等片刻 kubernetes 即可安装成功 安装 canal 网络插件从 canal 官方文档参考，如下网址下载 2 个文件并且安装，其中一个是配置 canal 的 RBAC 权限，一个是部署 canal 的 DaemonSet。 12345# kubectl apply -f https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/canal/rbac.yamlclusterrole.rbac.authorization.k8s.io "calico" createdclusterrole.rbac.authorization.k8s.io "flannel" createdclusterrolebinding.rbac.authorization.k8s.io "canal-flannel" createdclusterrolebinding.rbac.authorization.k8s.io "canal-calico" created 12345678910# kubectl apply -f https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/canal/canal.yamlconfigmap "canal-config" createddaemonset.extensions "canal" createdcustomresourcedefinition.apiextensions.k8s.io "felixconfigurations.crd.projectcalico.org" createdcustomresourcedefinition.apiextensions.k8s.io "bgpconfigurations.crd.projectcalico.org" createdcustomresourcedefinition.apiextensions.k8s.io "ippools.crd.projectcalico.org" createdcustomresourcedefinition.apiextensions.k8s.io "clusterinformations.crd.projectcalico.org" createdcustomresourcedefinition.apiextensions.k8s.io "globalnetworkpolicies.crd.projectcalico.org" createdcustomresourcedefinition.apiextensions.k8s.io "networkpolicies.crd.projectcalico.org" createdserviceaccount "canal" created 等待所有节点运行成功之后查看 canal 的安装状态，可以看到 canal 和 kube-dns 都已经运行正常，一个功能正常的 matser 节点和必须的网络插件就部署完毕了。 123456789101112# kubectl get nodesNAME STATUS ROLES AGE VERSIONubuntu Ready master 5m v1.9.0# kubectl get pod -n kube-system -o wideNAME READY STATUS RESTARTS AGE IP NODEcanal-4n2tw 3/3 Running 0 1m 192.168.85.134 ubuntuetcd-ubuntu 1/1 Running 0 3m 192.168.85.134 ubuntukube-apiserver-ubuntu 1/1 Running 0 3m 192.168.85.134 ubuntukube-controller-manager-ubuntu 1/1 Running 0 3m 192.168.85.134 ubuntukube-dns-6f4fd4bdf-gpvh4 3/3 Running 0 3m 10.244.0.5 ubuntukube-proxy-kbdvk 1/1 Running 0 3m 192.168.85.134 ubuntukube-scheduler-ubuntu 1/1 Running 0 3m 192.168.85.134 ubuntu ubuntu-master 将Slave节点加入集群不同于 Master 节点， Slave 节点所需的镜像较少，在 Slave 节点执行以下命令下载镜像 1234567891011# downloaddocker pull xiaoyaolangzi/kube-proxy-amd64:v1.9.1docker pull xiaoyaolangzi/pause-amd64:3.0# rename tagdocker tag xiaoyaolangzi/kube-proxy-amd64:v1.9.1 gcr.io/google_containers/kube-proxy-amd64:v1.9.1docker tag xiaoyaolangzi/pause-amd64:3.0 gcr.io/google_containers/pause-amd64:3.0# deletedocker rmi xiaoyaolangzi/kube-proxy-amd64:v1.9.1docker rmi xiaoyaolangzi/pause-amd64:3.0 在 Slave 节点执行如下的命令,将 Slave 节点加入集群。正常的返回信息如下： 12345678910111213141516#kubeadm join --token 7e9211.94f5426a55b22eb3 192.168.85.134:6443 --discovery-token-ca-cert-hash sha256:cb009a5dde6b127d4844cffe04163a0ce07f10557cd0c2ccfa4c51eb5536ab02[preflight] Running pre-flight checks. [WARNING FileExisting-crictl]: crictl not found in system pathSuggestion: go get github.com/kubernetes-incubator/cri-tools/cmd/crictl[discovery] Trying to connect to API Server "192.168.0.200:6443"[discovery] Created cluster-info discovery client, requesting info from "https://192.168.0.200:6443"[discovery] Requesting info from "https://192.168.0.200:6443" again to validate TLS against the pinned public key[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server "192.168.0.200:6443"[discovery] Successfully established connection with API Server "192.168.0.200:6443"This node has joined the cluster:* Certificate signing request was sent to master and a response was received.* The Kubelet was informed of the new secure connection details.Run 'kubectl get nodes' on the master to see this node join the cluster. ::: warning 注意此命令是你在 Master 节点执行 kubeadm init 时返回的命令，此命令只是一个示例，直接复制上面的命令 ip, token 等信息都是不匹配的。::: 返回 Master 节点，等待节点加入完毕后查看节点状态 12345678910111213141516# kubectl get nodesNAME STATUS ROLES AGE VERSIONubuntu-master NotReady master 10m v1.9.0ubuntu-1 NotReady &lt;none&gt; 6m v1.9.0# kubectl get pod -n kube-system -o wideNAME READY STATUS RESTARTS AGE IP NODEcanal-s8hks 3/3 Running 0 21m 192.168.85.133 ubuntu-1canal-wc4fh 3/3 Running 0 28m 192.168.85.134 ubuntuetcd-ubuntu 1/1 Running 0 23m 192.168.85.134 ubuntukube-apiserver-ubuntu 1/1 Running 0 23m 192.168.85.134 ubuntukube-controller-manager-ubuntu 1/1 Running 0 23m 192.168.85.134 ubuntukube-dns-6f4fd4bdf-pcdls 3/3 Running 0 29m 10.244.0.10 ubuntukube-proxy-fn69j 1/1 Running 0 21m 192.168.85.133 ubuntu-1kube-proxy-jjpz6 1/1 Running 0 29m 192.168.85.134 ubuntukube-scheduler-ubuntu 1/1 Running 0 23m 192.168.85.134 ubuntukubernetes-dashboard-5bd6f767c7-9msq6 1/1 Running 0 28m 10.244.0.9 ubuntu 返回 Slave 节点，查看下载的镜像列表 1234567# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEquay.io/calico/node v3.0.8 6e991381712e 3 weeks ago 248 MBquay.io/calico/cni v2.0.6 dbeb77ece97f 3 weeks ago 69.1 MBgcr.io/google_containers/pause-amd64 3.0 3773f3dd7d9b 5 months ago 747 kBgcr.io/google_containers/kube-proxy-amd64 v1.9.1 d6b97770e509 5 months ago 109 MBquay.io/coreos/flannel v0.9.1 2b736d06ca4c 7 months ago 51.3 MB 可以发现，Slave 节点也下载了我们必须使用的镜像。到此为止，我们已经成功的在本地虚拟机上搭建起来了一个 Kubernetes 测试集群。这个测试集群拥有完整的功能，已经可以供我们正常使用 Kubernetes 了。 可能需要使用到的命令 让 Master 也运行 pod（默认 master 不运行 pod ）,这样在测试环境做是可以的，不建议在生产环境如此操作。 12345# kubectl taint nodes --all node-role.kubernetes.io/master-node "ubuntu-master" untaintedtaint "node-role.kubernetes.io/master:" not foundtaint "node-role.kubernetes.io/master:" not foundtaint "node-role.kubernetes.io/master:" not found 重置集群状态 kubeadm reset，不是每次执行 kubeadm init 或者 kubeadm join 命令都能保证执行成功的。所以在这些命令执行失败之后我们需要 kubeadm reset 来重置一下集群的状态。 123456789# kubeadm reset[preflight] Running pre-flight checks.[reset] Stopping the kubelet service.[reset] Unmounting mounted directories in "/var/lib/kubelet"[reset] Removing kubernetes-managed containers.[reset] No etcd manifest found in "/etc/kubernetes/manifests/etcd.yaml". Assuming external etcd.[reset] Deleting contents of stateful directories: [/var/lib/kubelet /etc/cni/net.d /var/lib/dockershim /var/run/kubernetes][reset] Deleting contents of config directories: [/etc/kubernetes/manifests /etc/kubernetes/pki][reset] Deleting files: [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf] 使用 kubectl describe --namespace=kube-system pod &lt;pod_name&gt; 查找错误原因，如果在部署过程中发现有状态错误的 Pod，则可以执行该命令来查看错误原因，比较常见的问题可能是镜像没有下载。 使用 kebeadm help 和 kubectl help 来查看对应的命令行工具的使用文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# kubeadm helpkubeadm: easily bootstrap a secure Kubernetes cluster. ┌──────────────────────────────────────────────────────────┐ │ KUBEADM IS CURRENTLY IN BETA │ │ │ │ But please, try it out and give us feedback at: │ │ https://github.com/kubernetes/kubeadm/issues │ │ and at-mention @kubernetes/sig-cluster-lifecycle-bugs │ │ or @kubernetes/sig-cluster-lifecycle-feature-requests │ └──────────────────────────────────────────────────────────┘Example usage: Create a two-machine cluster with one master (which controls the cluster), and one node (where your workloads, like Pods and Deployments run). ┌──────────────────────────────────────────────────────────┐ │ On the first machine: │ ├──────────────────────────────────────────────────────────┤ │ master# kubeadm init │ └──────────────────────────────────────────────────────────┘ ┌──────────────────────────────────────────────────────────┐ │ On the second machine: │ ├──────────────────────────────────────────────────────────┤ │ node# kubeadm join &lt;arguments-returned-from-init&gt; │ └──────────────────────────────────────────────────────────┘ You can then repeat the second step on as many other machines as you like.Usage: kubeadm [command]Available Commands: alpha Experimental sub-commands not yet fully functional. completion Output shell completion code for the specified shell (bash or zsh). config Manage configuration for a kubeadm cluster persisted in a ConfigMap in the cluster. init Run this command in order to set up the Kubernetes master. join Run this on any machine you wish to join an existing cluster reset Run this to revert any changes made to this host by 'kubeadm init' or 'kubeadm join'. token Manage bootstrap tokens. upgrade Upgrade your cluster smoothly to a newer version with this command. version Print the version of kubeadmUse "kubeadm [command] --help" for more information about a command. 参考文章连接 官方：kubeadm 安装文档 官方：利用 kubeadm 创建集群 官方：kubeadm 使用教程 官方：kubernetes 更新日志 官方：在 Ubuntu 系统中下载 Docker 第三方：Kubernetes Handbook 第三方：Kubernetes 对 Docker 的版本支持列表 第三方：如何确定 kubernetes 依赖的各个组件版本？]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot 学习笔记]]></title>
    <url>%2FSpring%20boot%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[spring boot 官方生成demospring boot 2017年9月20日21:00:11，进行文档的更新]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何实现 QQ 第三方登录]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20QQ%20%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95.html</url>
    <content type="text"><![CDATA[虽然互联网是开放的，但是总是有那么几家巨头互联网公司把控着绝大多数的流量入口，例如腾讯、阿里、微博等等。但是中小型网站也要生存，需要流量；互联网巨头也要提高自己的影响力，增加自己的战略布局；广大用户也懒得记过多的账号密码，试想一下如果每个用户没使用一个App就要注册一个账号密码，这个场景也的确是不太友好。这个需求场景快速的催化了三方用户体系的发展。 因此对于中小型网站或者App的开发者来说，添加第三方登录的好处就是降低获取用户的成本，借由互联网巨头公司数亿级别的用户群中相对快速的获取自己的潜在用户，因此应用中添加第三方登录就显得几乎是必须的了。那么今天以QQ登陆为例，来实现一个最简单的第三方登陆。 目前主流的第三方登录都是依赖的Oauth2.0协议实现的，最常见的就是在各种中小型网站或者App中的QQ登录，微信登录等等。所以我建议想要学习和实现第三方登录同学去了解下这个协议。 理解OAuth 2.0 - 阮一峰 准备工作如果要实现QQ第三方登录我们必须要有的东西是什么呢 登录QQ互联官网，注册成为QQ互联平台开发者，注册一个网站应用 准备一个可访问的域名 一个服务器来承载我们的网站应用。阿里云，腾讯云，或者是自己搭建的都可以 注意：如果你和我一样，只是为了测试或者体验一下第三方登录，增加一下自己的技能书的话，那么第二点和第三点都不是必须的。 在QQ互联注册我们的应用首先要登陆QQ互联官网 ，点击创建应用 &gt; 创建网站应用 &gt; 填写资料 &gt; 注册一个网站应用。 在申请网站应用过程中，需要一些以下资料。如下图所示： 注意： 域名：网站应用的域名。 网站回调域：用户访问QQ互联登录校验成功后的回调地址。这个地址非常重要。建议在回调页面可以做一些保存QQ用户信息的操作，比如用户openId、accessToken、昵称、QQ空间头像等信息。回调地址支持多个，应用审核后也可以再次编辑。 提供方：一般为公司名称或者开发者的名称 网站备案号：网站域名的备案信息，如果是在万网，或者阿里云购买的域名，可以使用阿里云备案，还是比较方便 网站图标：会在一些场景显示出来，供展示使用 用户使用QQ登录时的提示界面（以熊猫直播的第三方登录为例），展示的信息有网站名称，网站图标，网站域名： 但是有些同学会问：我只是学习以下第三方登录，我怎么测试？答案是：正常填写资料， 在网站回调域一栏填写一个可以在本机正常访问的地址在网站回调域一栏填写一个可以在本机正常访问的地址在网站回调域一栏填写一个可以在本机正常访问的地址 我个人在本地使用的网站回调域是 http://127.0.0.1:8080/qq-login.html。 只要是在本机可以正常访问就可以。其他的域名，备案号等没有就随便填，自己有的话就填上。如果填写完成后，等待审核，资料都OK的话，应该会审核成功，如果有错误数据，比如不合法的备案号。那么会审核失败。审核失败的应用我们可以拿来作为测试应用使用。 注意：审核失败的应用，只有对应的登录QQ互联的QQ号可以使用正常的第三方登录功能。换句话说，失败的应用我们依然可以用来测试，只不过对测试的账户有所限制。 网站应用审核成功后，在应用管理界面可以看到我们的应用。如下图： 此时我们就可以用这个网站应用来测测试一下QQ第三方登录的实现过程了 实现QQ登录本部分以JavaScript和QQ互联官网给出的jssdk为例，代码非常简单。 新建一个html文件如下： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;qq登录测试&lt;/title&gt;&lt;/head&gt;&lt;body style="margin: 0 auto;width: 400px;"&gt; &lt;h1&gt;这里是QQ登录测试界面&lt;/h1&gt; &lt;span id="qqLoginBtn"&gt;&lt;/span&gt; &lt;!-- 引入QQ第三方登陆的javascriot的SDK，appid，redirecturi修改为自己创建的应用的数据，要注意redirecturi一定要和我们申请的网站应用中的回调域完全匹配，否则会报错 --&gt; &lt;script type="text/javascript" src="http://qzonestyle.gtimg.cn/qzone/openapi/qc_loader.js" data-appid="101415280" data-redirecturi="http://127.0.0.1:8080/qq-login.html" charset="utf-8"&gt;&lt;/script&gt; &lt;!-- 使用官方默认的方法放置QQ登录按钮 --&gt; &lt;script type="text/javascript"&gt; QC.Login(&#123; btnId: "qqLoginBtn" //插入按钮的节点id &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面如下所示 点击QQ登录，此时用户点击QQ登录后，QQ会默认拉取QQ或者TIM的登录状态，如果用户电脑上存在这两款软件的登录状态，那么登录界面如下所示，如果没有，则只显示二维码登录。 用户登录成功之后会回调页面，为了方便测试，我的回调地址同样是 http://127.0.0.1:8080/qq-login.html。登录成功，返回到这个地址，你会发现原来的界面变成下图所示 这代表用户已经登录成功。打开控制台，发现cookie里面已经存储了一些和QQ相关的信息。此时我们可以通过SDK提供的方法来获取用户的数据。在上面的qq-login.html页面中增加以下代码： 1234567891011121314&lt;button onclick="getMe()"&gt;getMe&lt;/button&gt;&lt;!-- 添加获取用户数据的方法 --&gt;&lt;script&gt; function getMe() &#123; if (QC.Login.check()) &#123; QC.Login.getMe(function (openId, accessToken) &#123; console.log('openId', openId); console.log('accessToken', accessToken); &#125;) &#125; else &#123; console.log('不好意思用户没有登录'); &#125; &#125;&lt;/script&gt; 在用户成功登录之后，我们点击getMe按钮，发现我们成功的获取到了用户的openId，accessToken并且已经打印在了控制台当中。 openId：对于每一个网站应用的每一个QQ用户，都有一个唯一的openId与之对应。简单说就是对于我们的网站。openId就是每个QQ用户的唯一标示，可以当做主键来使用accessToken：当前的用户的口令，在口令的过期时间内，可以直接通过accessToken来和QQ的服务器进行交互，比如说获取用户的昵称，头像的等信息，所有建议口令存储在安全性更高的数据库中。 QQ登录的业务逻辑是怎么样的？到目前为止，我们已经成功的获取到了使用QQ用户的唯一标示，那么我们QQ登录的具体的业务逻辑应该怎么写呢？如何实现用户点击QQ头像就直接登录成功了呢？ 其实我们首先要明白。一个网站的用户系统是可大可小的问题，一个大型网站的用户系统本身就是一个非常庞大的模块。要实现这样的支持第三方登录的用户系统，还需要后台乃至数据存储方面的配合。现在我们获取到了QQ登录非常重要的openId，accessToken。那么如何去存储这些信息的？首先我们要设计一个合理的用户存储结构。此处推荐一篇廖雪峰大大的文档。这三篇将的非常清楚 设计一个可扩展的用户登录系统 (1) 设计一个可扩展的用户登录系统 (2) 设计一个可扩展的用户登录系统 (3) 简单来说就是在数据库中添加一个表oauth_qq，记录下我们获取的QQ的第三方登录的信息，然后通过外键的方式和我们的用户表Users关联起来。 id user_id openid access_token 01 user_01 qq_123456 xxxxxx 02 user_02 qq_456123 xxxxxx 然后我们把oauth_qq这张表的数据作为一种验证方式，在用户使用QQ登录的时候首先验证一下用户在数据库中心的信息，用户验证过第三方的QQ信息，就可以直接登录了。 如果要添加用户绑定或者解除第三方登录的信息，直接删除对应的oauth_qq表的记录就可以了，不过在删除之前，为了安全起见，建议做一下用户身份校验。 到这里一个简单的第三方登录就实现完成了，但是其实这篇文章讲的比较粗浅，只是给大家提供一个实现第三方登录的思路。如果大家想要实现更多的功能，或者集成更多平台的第三方登录。一定要先对Oauth 2.0协议有一个比较深的理解。其实Oauth 2.0协议除了可以让我们使用QQ这样的第三方授权协议之外，甚至我们自己也可以根据此协议搭建一个Server端来给其他的网站或者应用进行授权，不过这需要我们掌握更多的知识，对Oauth 2.0有更加深入的了解才可以。 后记学习一项新技术最好的办法就是去看官方文档。第一手的资料永远是最有参考价值的。官方文档的完整性和权威性是不可替代的，可以让我们有一个完整的知识结构，而不会让你在知识结构上出现大的漏洞。但是这并不是说博客类的文章就没有意义，博客往往是琐碎的一点一点的知识片段，是使用经验，让我们少走一些弯路。 本文中引用连接和一些参考资料汇总： QQ互联文档中心 QQ互联 JS_SDK使用说明 Oauth 2.0 官网 Oauth 2.0 维基百科 理解OAuth 2.0 - 阮一峰 设计一个可扩展的用户登录系统 (1) - 廖雪峰 设计一个可扩展的用户登录系统 (2) - 廖雪峰 设计一个可扩展的用户登录系统 (3) - 廖雪峰]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Java</tag>
        <tag>第三方登录</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 示例标签，语法和脚本测试页面]]></title>
    <url>%2FHexo%20%E7%A4%BA%E4%BE%8B%E6%A0%87%E7%AD%BE%EF%BC%8C%E8%AF%AD%E6%B3%95%E5%92%8C%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2.html</url>
    <content type="text"><![CDATA[上图为腾讯云COS图床图片 一级标题some content 二级标题some content 三级标题some content 四级标题some content 五级标题some content 六级标题some content]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[顶级特效是如何制作的？《权力的游戏》S7E4 幕后“烈火燎原”]]></title>
    <url>%2F%E9%A1%B6%E7%BA%A7%E7%89%B9%E6%95%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E7%9A%84%EF%BC%9F%E3%80%8A%E6%9D%83%E5%8A%9B%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8BS7E4%20%E5%B9%95%E5%90%8E%E2%80%9C%E7%83%88%E7%81%AB%E7%87%8E%E5%8E%9F%E2%80%9D.html</url>
    <content type="text"><![CDATA[《权力的游戏》S7E4幕后“The Loot Train Attack”拍摄制作过程和相关主创采访。 UP听译，如有错误还望海涵~ Tips: 点击视频右上角的去Bilibili观看，可以查看高清 1080P 源视频 ~~~]]></content>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树人格鲁特宝宝的特效是如何制作的？《银河护卫队2》幕后]]></title>
    <url>%2F%E6%A0%91%E4%BA%BA%E6%A0%BC%E9%B2%81%E7%89%B9%E5%AE%9D%E5%AE%9D%E7%9A%84%E7%89%B9%E6%95%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E7%9A%84%EF%BC%9F%E3%80%8A%E9%93%B6%E6%B2%B3%E6%8A%A4%E5%8D%AB%E9%98%9F2%E3%80%8B%E5%B9%95%E5%90%8E.html</url>
    <content type="text"><![CDATA[银河护卫队2花絮，格鲁特宝宝是如何制作的 UP听译，如有错误还望海涵~ Tips: 点击视频右上角的去Bilibili观看，可以查看高清 1080P 源视频 ~~~]]></content>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
</search>
